-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package sturdy-while
@version 0.2.0.0


-- | Syntax for the While language
module Exceptions.Syntax

-- | Expressions of the While language. Each expression can be identified
--   with a unique label.
data Expr
Var :: Text -> Label -> Expr
BoolLit :: Bool -> Label -> Expr
And :: Expr -> Expr -> Label -> Expr
Or :: Expr -> Expr -> Label -> Expr
Not :: Expr -> Label -> Expr
NumLit :: Int -> Label -> Expr
RandomNum :: Label -> Expr
Add :: Expr -> Expr -> Label -> Expr
Sub :: Expr -> Expr -> Label -> Expr
Mul :: Expr -> Expr -> Label -> Expr
Div :: Expr -> Expr -> Label -> Expr
Eq :: Expr -> Expr -> Label -> Expr
Lt :: Expr -> Expr -> Label -> Expr
Throw :: Text -> Expr -> Label -> Expr
type LExpr = State Label Expr
true :: LExpr
false :: LExpr
(<) :: LExpr -> LExpr -> LExpr
(~=) :: LExpr -> LExpr -> LExpr

-- | Statements of the while language.
data Statement
While :: Expr -> Statement -> Label -> Statement
If :: Expr -> Statement -> Statement -> Label -> Statement
Assign :: Text -> Expr -> Label -> Statement
Begin :: [Statement] -> Label -> Statement
TryCatch :: Statement -> Text -> Text -> Statement -> Label -> Statement
Finally :: Statement -> Statement -> Label -> Statement
type LStatement = State Label Statement
while :: LExpr -> [LStatement] -> State Label Statement
whileLoops :: Prism' [Statement] ((Expr, Statement, Label), [Statement])
ifExpr :: State Label Expr -> [State Label Statement] -> [State Label Statement] -> State Label Statement
begin :: [LStatement] -> LStatement
tryCatch :: LStatement -> Text -> Text -> LStatement -> LStatement
finally :: LStatement -> LStatement -> LStatement
(=:) :: Text -> State Label Expr -> State Label Statement
infix 0 =:
blocks :: [Statement] -> [Statement]
instance GHC.Generics.Generic Exceptions.Syntax.Statement
instance GHC.Classes.Eq Exceptions.Syntax.Statement
instance GHC.Classes.Ord Exceptions.Syntax.Statement
instance GHC.Generics.Generic Exceptions.Syntax.Expr
instance GHC.Classes.Eq Exceptions.Syntax.Expr
instance GHC.Classes.Ord Exceptions.Syntax.Expr
instance GHC.Show.Show Exceptions.Syntax.Statement
instance Data.Label.HasLabel Exceptions.Syntax.Statement Data.Label.Label
instance Data.Hashable.Class.Hashable Exceptions.Syntax.Statement
instance Data.String.IsString Exceptions.Syntax.LExpr
instance GHC.Show.Show Exceptions.Syntax.Expr
instance GHC.Num.Num (Control.Monad.Trans.State.Lazy.State Data.Label.Label Exceptions.Syntax.Expr)
instance Data.Label.HasLabel Exceptions.Syntax.Expr Data.Label.Label
instance Data.Hashable.Class.Hashable Exceptions.Syntax.Expr
instance Data.Order.PreOrd Exceptions.Syntax.Expr


-- | Syntax for the While language
module Syntax

-- | Expressions of the While language. Each expression can be identified
--   with a unique label.
data Expr
Var :: Text -> Label -> Expr
BoolLit :: Bool -> Label -> Expr
And :: Expr -> Expr -> Label -> Expr
Or :: Expr -> Expr -> Label -> Expr
Not :: Expr -> Label -> Expr
NumLit :: Int -> Label -> Expr
RandomNum :: Label -> Expr
Add :: Expr -> Expr -> Label -> Expr
Sub :: Expr -> Expr -> Label -> Expr
Mul :: Expr -> Expr -> Label -> Expr
Div :: Expr -> Expr -> Label -> Expr
Eq :: Expr -> Expr -> Label -> Expr
Lt :: Expr -> Expr -> Label -> Expr
type LExpr = State Label Expr
true :: LExpr
false :: LExpr
(<) :: LExpr -> LExpr -> LExpr
(~=) :: LExpr -> LExpr -> LExpr

-- | Statements of the while language.
data Statement
While :: Expr -> Statement -> Label -> Statement
If :: Expr -> Statement -> Statement -> Label -> Statement
Assign :: Text -> Expr -> Label -> Statement
Begin :: [Statement] -> Label -> Statement
type LStatement = State Label Statement
while :: LExpr -> [LStatement] -> State Label Statement
whileLoops :: Prism' [Statement] ((Expr, Statement, Label), [Statement])
ifExpr :: State Label Expr -> [State Label Statement] -> [State Label Statement] -> State Label Statement
begin :: [LStatement] -> LStatement
(=:) :: Text -> State Label Expr -> State Label Statement
infix 0 =:
blocks :: [Statement] -> [Statement]
instance GHC.Generics.Generic Syntax.Statement
instance GHC.Classes.Eq Syntax.Statement
instance GHC.Classes.Ord Syntax.Statement
instance GHC.Generics.Generic Syntax.Expr
instance GHC.Classes.Eq Syntax.Expr
instance GHC.Classes.Ord Syntax.Expr
instance GHC.Show.Show Syntax.Statement
instance Data.Label.HasLabel Syntax.Statement Data.Label.Label
instance Data.Hashable.Class.Hashable Syntax.Statement
instance Data.String.IsString Syntax.LExpr
instance GHC.Show.Show Syntax.Expr
instance GHC.Num.Num (Control.Monad.Trans.State.Lazy.State Data.Label.Label Syntax.Expr)
instance Data.Label.HasLabel Syntax.Expr Data.Label.Label
instance Data.Hashable.Class.Hashable Syntax.Expr
instance Data.Order.PreOrd Syntax.Expr


-- | Generic interpreter for the While-Language.
module GenericInterpreter
type Prog = [Statement]

-- | Generic interpreter for expressions of the While-language. It is an
--   arrow computation <tt>c Expr v</tt> that consumes expressions and
--   produces values. The interpreter is parameterized by the type of
--   values <tt>v</tt>, addresses <tt>addr</tt>, environment <tt>env</tt>
--   and arrow type <tt>c</tt>. It uses the <tt>IsVal</tt> interface to
--   combine values and uses the <tt>ArrowEnv</tt> and <tt>ArrowStore</tt>
--   interface to access the environment.
eval :: (Show addr, ArrowChoice c, ArrowRand v c, ArrowEnv Text addr env c, ArrowStore addr v c, ArrowFail e c, IsString e, IsVal v c, Join c ((addr, Text), Text) v, Join c ((v, addr), addr) v) => c Expr v

-- | Generic interpreter for statements of the While-language. It is an
--   arrow computation <tt>c [Statement] ()</tt> that consumes statements
--   and does not produces a result. The interpreter is parameterized by
--   the type of values <tt>v</tt>, addresses <tt>addr</tt>, environment
--   <tt>env</tt> and arrow type <tt>c</tt>.
run :: (Show addr, ArrowChoice c, ArrowFix [Statement] () c, ArrowEnv Text addr env c, ArrowStore addr v c, ArrowAlloc (Text, v, Label) addr c, ArrowFail e c, ArrowRand v c, IsString e, IsVal v c, Join c ((addr, Text), Text) v, Join c ((addr, (Text, v, Label)), (Text, v, Label)) addr, Join c ((v, addr), addr) v, JoinVal c ([Statement], [Statement]) ()) => c [Statement] ()

-- | Interface for value operations.
class Arrow c => IsVal v c | c -> v where {

    -- | This constraint allows the abstract interpreter to join the results of
    --   an <tt>if</tt> statement.
    type family JoinVal (c :: * -> * -> *) x y :: Constraint;
}
boolLit :: IsVal v c => c (Bool, Label) v
and :: IsVal v c => c (v, v, Label) v
or :: IsVal v c => c (v, v, Label) v
not :: IsVal v c => c (v, Label) v
numLit :: IsVal v c => c (Int, Label) v
add :: IsVal v c => c (v, v, Label) v
sub :: IsVal v c => c (v, v, Label) v
mul :: IsVal v c => c (v, v, Label) v
div :: IsVal v c => c (v, v, Label) v
eq :: IsVal v c => c (v, v, Label) v
lt :: IsVal v c => c (v, v, Label) v
if_ :: (IsVal v c, JoinVal c (x, y) z) => c x z -> c y z -> c (v, (x, y)) z


-- | Interval Analysis for the While language.
module IntervalAnalysis

-- | Abstract values are either abstract booleans or intervals.
data Val
BoolVal :: Bool -> Val
NumVal :: IV -> Val
Top :: Val
type IV = Interval (InfiniteNumber Int)
type Addr = FreeCompletion Label

-- | The interval analysis instantiates the generic interpreter <a>run</a>
--   with the components for fixpoint computation (<a>FixT</a>),
--   termination (<a>TerminatingT</a>), failure (<a>ErrorT</a>), store
--   (<a>StoreT</a>), environments (<a>EnvT</a>), and values
--   (<a>IntervalT</a>).
run :: ?bound :: IV => Int -> [(Text, Addr)] -> [LStatement] -> Terminating (Error (Pow String) (Map Addr Val))
newtype IntervalT c x y
IntervalT :: c x y -> IntervalT c x y
[runIntervalT] :: IntervalT c x y -> c x y
widening :: Widening IV -> Widening Val
instance Data.Order.Complete (c x y) => Data.Order.Complete (IntervalAnalysis.IntervalT c x y)
instance Data.Order.PreOrd (c x y) => Data.Order.PreOrd (IntervalAnalysis.IntervalT c x y)
instance Control.Arrow.Abstract.Join.ArrowJoin c => Control.Arrow.Abstract.Join.ArrowJoin (IntervalAnalysis.IntervalT c)
instance Control.Arrow.Store.ArrowStore var val c => Control.Arrow.Store.ArrowStore var val (IntervalAnalysis.IntervalT c)
instance Control.Arrow.Environment.ArrowEnv var val env c => Control.Arrow.Environment.ArrowEnv var val env (IntervalAnalysis.IntervalT c)
instance Control.Arrow.Except.ArrowExcept exc c => Control.Arrow.Except.ArrowExcept exc (IntervalAnalysis.IntervalT c)
instance Control.Arrow.Fail.ArrowFail e c => Control.Arrow.Fail.ArrowFail e (IntervalAnalysis.IntervalT c)
instance Control.Arrow.ArrowChoice c => Control.Arrow.ArrowChoice (IntervalAnalysis.IntervalT c)
instance Control.Arrow.Arrow c => Control.Arrow.Arrow (IntervalAnalysis.IntervalT c)
instance Control.Category.Category c => Control.Category.Category (IntervalAnalysis.IntervalT c)
instance Data.Profunctor.Unsafe.Profunctor c => Data.Profunctor.Unsafe.Profunctor (IntervalAnalysis.IntervalT c)
instance GHC.Generics.Generic IntervalAnalysis.Val
instance GHC.Classes.Eq IntervalAnalysis.Val
instance Control.Arrow.Fix.ArrowFix x y c => Control.Arrow.Fix.ArrowFix x y (IntervalAnalysis.IntervalT c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Alloc.ArrowAlloc (Data.Text.Internal.Text, IntervalAnalysis.Val, Data.Label.Label) IntervalAnalysis.Addr (IntervalAnalysis.IntervalT c)
instance (Data.String.IsString e, Control.Arrow.ArrowChoice c, Control.Arrow.Fail.ArrowFail e c, Control.Arrow.Abstract.Join.ArrowJoin c) => GenericInterpreter.IsVal IntervalAnalysis.Val (IntervalAnalysis.IntervalT c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Random.ArrowRand IntervalAnalysis.Val (IntervalAnalysis.IntervalT c)
instance Data.Order.PreOrd IntervalAnalysis.Val
instance Data.Order.UpperBounded IntervalAnalysis.Val
instance Data.Order.Complete IntervalAnalysis.Val
instance GHC.Show.Show IntervalAnalysis.Val
instance Data.Hashable.Class.Hashable IntervalAnalysis.Val


-- | Reaching Definition Analysis for the While language.
module ReachingDefinitionsAnalysis

-- | Calculates the entry sets of which definitions may be reached for each
--   statment. The analysis instantiates the generic interpreter <a>run</a>
--   with analysis components for fixpoint computation (<a>FixT</a>),
--   termination (<a>TerminatingT</a>), failure (<a>ErrorT</a>), store
--   (<a>StoreT</a>), environments (<a>EnvT</a>), and values
--   (<a>IntervalT</a>)
run :: ?bound :: IV => Int -> [LStatement] -> [(Label, Map Text (Pow Label))]
combineMaps :: (Identifiable k, Identifiable a) => Map k a -> Map a v -> Map k v
dropValues :: Map a (v, l) -> Map a l
joinOnKey :: (Identifiable k', Complete v') => (k -> v -> Maybe (k', v')) -> HashMap k v -> HashMap k' v'
instance Data.Label.HasLabel (x, [Syntax.Statement]) Data.Label.Label


-- | Generic interpreter for the While-Language.
module Exceptions.GenericInterpreter
type Prog = [Statement]

-- | Generic interpreter for expressions of the While-language. It is an
--   arrow computation <tt>c Expr v</tt> that consumes expressions and
--   produces values. The interpreter is parameterized by the type of
--   values <tt>v</tt>, addresses <tt>addr</tt>, environment <tt>env</tt>
--   and arrow type <tt>c</tt>. It uses the <tt>IsVal</tt> interface to
--   combine values and uses the <tt>ArrowEnv</tt> and <tt>ArrowStore</tt>
--   interface to access the environment.
eval :: (Show addr, ArrowChoice c, ArrowRand v c, ArrowEnv Text addr env c, ArrowStore addr v c, ArrowFail err c, IsString err, ArrowExcept exc c, IsVal v c, IsException exc v c, Join c ((addr, Text), Text) v, Join c ((v, addr), addr) v) => c Expr v

-- | Generic interpreter for statements of the While-language. It is an
--   arrow computation <tt>c [Statement] ()</tt> that consumes statements
--   and does not produces a result. The interpreter is parameterized by
--   the type of values <tt>v</tt>, addresses <tt>addr</tt>, environment
--   <tt>env</tt> and arrow type <tt>c</tt>.
run :: (Show addr, ArrowChoice c, ArrowFix [Statement] () c, ArrowEnv Text addr env c, ArrowStore addr v c, ArrowAlloc (Text, v, Label) addr c, ArrowFail err c, ArrowExcept exc c, ArrowRand v c, IsString err, IsVal v c, IsException exc v c, Join c ((addr, Text), Text) v, Join c ((addr, (Text, v, Label)), (Text, v, Label)) addr, Join c ((v, addr), addr) v, Join c ((), ((Statement, (Text, Text, Statement, Label)), exc)) (), Join c (((Statement, Statement), ()), ((Statement, Statement), exc)) (), JoinVal c ([Statement], [Statement]) (), JoinExc c ((v, (Text, Statement, Label)), (Text, Statement, Label)) ()) => c [Statement] ()
class IsException exc v c | c -> v where {
    type family JoinExc (c :: * -> * -> *) x y :: Constraint;
}
namedException :: IsException exc v c => c (Text, v) exc
matchException :: (IsException exc v c, JoinExc c ((v, x), x) y) => c (v, x) y -> c x y -> c (Text, exc, x) y


-- | Interval Analysis for the While language.
module Exceptions.IntervalAnalysis

-- | Abstract values are either abstract booleans or intervals.
newtype Exception
Exception :: Map Text Val -> Exception

-- | The interval analysis instantiates the generic interpreter <a>run</a>
--   with the components for fixpoint computation (<a>FixT</a>),
--   termination (<a>TerminatingT</a>), failure (<a>ErrorT</a>), store
--   (<a>StoreT</a>), environments (<a>EnvT</a>), and values
--   (<a>IntervalT</a>).
run :: ?bound :: IV => Int -> [(Text, Addr)] -> [LStatement] -> Terminating (Error (Pow String) (Except Exception (Map Addr Val)))
instance Data.Order.Complete Exceptions.IntervalAnalysis.Exception
instance Data.Order.PreOrd Exceptions.IntervalAnalysis.Exception
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Abstract.Join.ArrowJoin c) => Exceptions.GenericInterpreter.IsException Exceptions.IntervalAnalysis.Exception IntervalAnalysis.Val (IntervalAnalysis.IntervalT c)


-- | Reaching Definition Analysis for the While language.
module Exceptions.ReachingDefinitionsAnalysis

-- | Calculates the entry sets of which definitions may be reached for each
--   statment. The analysis instantiates the generic interpreter <a>run</a>
--   with analysis components for fixpoint computation (<a>FixT</a>),
--   termination (<a>TerminatingT</a>), failure (<a>ErrorT</a>), store
--   (<a>StoreT</a>), environments (<a>EnvT</a>), and values
--   (<a>IntervalT</a>)
run :: ?bound :: IV => Int -> [LStatement] -> [(Label, Map Text (Pow Label))]
combineMaps :: (Identifiable k, Identifiable a) => Map k a -> Map a v -> Map k v
dropValues :: Map a (v, l) -> Map a l
joinOnKey :: (Identifiable k', Complete v') => (k -> v -> Maybe (k', v')) -> HashMap k v -> HashMap k' v'
instance Data.Label.HasLabel (x, [Exceptions.Syntax.Statement]) Data.Label.Label


-- | Concrete interpreter of the While language.
module ConcreteInterpreter

-- | Values of the While language can be booleans or numbers.
data Val
BoolVal :: Bool -> Val
NumVal :: Int -> Val
type Addr = Label

-- | The concrete interpreter of the while language instantiates <a>run</a>
--   with the concrete components for failure (<a>FailureT</a>), store
--   (<a>StoreT</a>), environments (<a>EnvT</a>), random numbers
--   (<a>RandomT</a>), and values (<a>ConcreteT</a>).
run :: [LStatement] -> Error String (HashMap Addr Val)

-- | The <a>ConcreteT</a> transformer defines the value operations for the
--   While language.
newtype ConcreteT c x y
ConcreteT :: c x y -> ConcreteT c x y
[runConcreteT] :: ConcreteT c x y -> c x y
instance Control.Arrow.Except.ArrowExcept exc c => Control.Arrow.Except.ArrowExcept exc (ConcreteInterpreter.ConcreteT c)
instance Control.Arrow.Store.ArrowStore addr val c => Control.Arrow.Store.ArrowStore addr val (ConcreteInterpreter.ConcreteT c)
instance Control.Arrow.Environment.ArrowEnv var addr env c => Control.Arrow.Environment.ArrowEnv var addr env (ConcreteInterpreter.ConcreteT c)
instance Control.Arrow.Fail.ArrowFail e c => Control.Arrow.Fail.ArrowFail e (ConcreteInterpreter.ConcreteT c)
instance Control.Arrow.ArrowChoice c => Control.Arrow.ArrowChoice (ConcreteInterpreter.ConcreteT c)
instance Control.Arrow.Arrow c => Control.Arrow.Arrow (ConcreteInterpreter.ConcreteT c)
instance Control.Category.Category c => Control.Category.Category (ConcreteInterpreter.ConcreteT c)
instance Data.Profunctor.Unsafe.Profunctor c => Data.Profunctor.Unsafe.Profunctor (ConcreteInterpreter.ConcreteT c)
instance GHC.Generics.Generic ConcreteInterpreter.Val
instance GHC.Show.Show ConcreteInterpreter.Val
instance GHC.Classes.Eq ConcreteInterpreter.Val
instance Control.Arrow.Fix.ArrowFix x y c => Control.Arrow.Fix.ArrowFix x y (ConcreteInterpreter.ConcreteT c)
instance Control.Arrow.Random.ArrowRand v c => Control.Arrow.Random.ArrowRand v (ConcreteInterpreter.ConcreteT c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Alloc.ArrowAlloc (Data.Text.Internal.Text, ConcreteInterpreter.Val, Data.Label.Label) ConcreteInterpreter.Addr (ConcreteInterpreter.ConcreteT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Fail.ArrowFail GHC.Base.String c) => GenericInterpreter.IsVal ConcreteInterpreter.Val (ConcreteInterpreter.ConcreteT c)
instance System.Random.Random ConcreteInterpreter.Val
instance Data.Hashable.Class.Hashable ConcreteInterpreter.Val


-- | Concrete interpreter of the While language.
module Exceptions.ConcreteInterpreter

-- | Values of the While language can be booleans or numbers.
type Exception = (Text, Val)

-- | The concrete interpreter of the while language instantiates <a>run</a>
--   with the concrete components for failure (<a>FailureT</a>), store
--   (<a>StoreT</a>), environments (<a>EnvT</a>), random numbers
--   (<a>RandomT</a>), and values (<a>ConcreteT</a>).
run :: [LStatement] -> Error String (Error Exception (HashMap Addr Val))
instance Control.Arrow.ArrowChoice c => Exceptions.GenericInterpreter.IsException Exceptions.ConcreteInterpreter.Exception ConcreteInterpreter.Val (ConcreteInterpreter.ConcreteT c)

-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package sturdy-pcf
@version 0.2.0.0

module Syntax

-- | Expressions of PCF. Each expression has a label, with which the
--   expression can be uniquely identified.
data Expr
Var :: Text -> Label -> Expr
Lam :: Text -> Expr -> Label -> Expr
App :: Expr -> Expr -> Label -> Expr
Zero :: Label -> Expr
Succ :: Expr -> Label -> Expr
Pred :: Expr -> Label -> Expr
IfZero :: Expr -> Expr -> Expr -> Label -> Expr
Y :: Expr -> Label -> Expr
Apply :: Expr -> Label -> Expr
var :: Text -> State Label Expr
lam :: Text -> State Label Expr -> State Label Expr
app :: State Label Expr -> State Label Expr -> State Label Expr
zero :: State Label Expr
succ :: State Label Expr -> State Label Expr
pred :: State Label Expr -> State Label Expr
ifZero :: State Label Expr -> State Label Expr -> State Label Expr -> State Label Expr
fix :: State Label Expr -> State Label Expr
apply :: Prism' (env, Expr) (env, (Expr, Label))
instance GHC.Classes.Eq Syntax.Expr
instance GHC.Show.Show Syntax.Expr
instance Data.Label.HasLabel Syntax.Expr Data.Label.Label
instance Data.String.IsString (Control.Monad.Trans.State.Lazy.State Data.Label.Label Syntax.Expr)
instance Data.Hashable.Class.Hashable Syntax.Expr

module GenericInterpreter

-- | The Generic interpreter for PCF. It uses the <a>IsNum</a> and
--   <a>IsClosure</a> interfaces to operate on numeric and closure values.
--   Furthermore, it uses <a>ArrowFix</a>, <a>ArrowEnv</a>, and
--   <a>ArrowFail</a> to compute the fixpoint, operate on the environment,
--   and fail with an error message.
eval :: (ArrowChoice c, ArrowFix Expr v c, ArrowEnv Text v env c, ArrowFail e c, IsString e, IsNum v c, IsClosure v env c, Join c ((v, Text), Text) v, Join c (Expr, Expr) v) => c Expr v

-- | Interface for numeric operations
class Arrow c => IsNum v c | c -> v where {
    type family Join (c :: * -> * -> *) x y :: Constraint;
}

-- | increments the given number value.
succ :: IsNum v c => c v v

-- | decrements the given number value.
pred :: IsNum v c => c v v

-- | creates the numeric value zero.
zero :: IsNum v c => c () v
if_ :: (IsNum v c, Join c (x, y) z) => c x z -> c y z -> c (v, (x, y)) z

-- | Interface for closures
class Arrow c => IsClosure v env c | c -> env, c -> v

-- | creates a closure from an expression and an environment.
closure :: IsClosure v env c => c (Expr, env) v

-- | applies a closure to an argument. The given continuation describes how
--   to evaluated the body of the closure.
applyClosure :: IsClosure v env c => c ((Expr, env), v) v -> c (v, v) v


-- | k-CFA analysis for PCF where numbers are approximated by intervals.
module IntervalAnalysis
type Env = Map Text (Text, CallString Label) Val

-- | Numeric values are approximated with bounded intervals, closure values
--   are approximated with a set of abstract closures.
data Val
NumVal :: IV -> Val
ClosureVal :: Closure Expr Env -> Val
Top :: Val

-- | Addresses for this analysis are variables paired with the k-bounded
--   call string.
type Addr = (Text, CallString Label)

-- | Run the abstract interpreter for the k-CFA / Interval analysis. The
--   arguments are the maximum interval bound, the depth <tt>k</tt> of the
--   longest call string, an environment, and the input of the computation.
evalInterval :: ?bound :: IV => Int -> [(Text, Val)] -> State Label Expr -> Terminating (Error (Pow String) Val)
newtype IntervalT c x y
IntervalT :: c x y -> IntervalT c x y
[runIntervalT] :: IntervalT c x y -> c x y
widening :: Widening IV -> Widening Val
type IV = Interval (InfiniteNumber Int)
instance GHC.Generics.Generic IntervalAnalysis.Val
instance GHC.Classes.Eq IntervalAnalysis.Val
instance Control.Arrow.Abstract.Join.ArrowJoin c => Control.Arrow.Abstract.Join.ArrowJoin (IntervalAnalysis.IntervalT c)
instance Control.Arrow.Fail.ArrowFail e c => Control.Arrow.Fail.ArrowFail e (IntervalAnalysis.IntervalT c)
instance Control.Arrow.ArrowChoice c => Control.Arrow.ArrowChoice (IntervalAnalysis.IntervalT c)
instance Control.Arrow.Arrow c => Control.Arrow.Arrow (IntervalAnalysis.IntervalT c)
instance Control.Category.Category c => Control.Category.Category (IntervalAnalysis.IntervalT c)
instance Data.Profunctor.Unsafe.Profunctor c => Data.Profunctor.Unsafe.Profunctor (IntervalAnalysis.IntervalT c)
instance Control.Arrow.Fix.ArrowFix x y c => Control.Arrow.Fix.ArrowFix x y (IntervalAnalysis.IntervalT c)
instance Control.Arrow.Environment.ArrowEnv var val env c => Control.Arrow.Environment.ArrowEnv var val env (IntervalAnalysis.IntervalT c)
instance (Data.String.IsString e, Control.Arrow.ArrowChoice c, Control.Arrow.Fail.ArrowFail e c, Control.Arrow.Abstract.Join.ArrowJoin c) => GenericInterpreter.IsNum IntervalAnalysis.Val (IntervalAnalysis.IntervalT c)
instance (Data.String.IsString e, Control.Arrow.ArrowChoice c, Control.Arrow.Fail.ArrowFail e c, Control.Arrow.Abstract.Join.ArrowJoin c) => GenericInterpreter.IsClosure IntervalAnalysis.Val (Data.Abstract.FiniteMap.Map Data.Text.Internal.Text IntervalAnalysis.Addr IntervalAnalysis.Val) (IntervalAnalysis.IntervalT c)
instance Data.Order.PreOrd IntervalAnalysis.Val
instance Data.Order.Complete IntervalAnalysis.Val
instance Data.Order.UpperBounded IntervalAnalysis.Val
instance Data.Label.HasLabel (Data.Abstract.FiniteMap.Map Data.Text.Internal.Text IntervalAnalysis.Addr IntervalAnalysis.Val, Syntax.Expr) Data.Label.Label
instance Data.Hashable.Class.Hashable IntervalAnalysis.Val
instance GHC.Show.Show IntervalAnalysis.Val
instance Control.Arrow.Trans.ArrowTrans IntervalAnalysis.IntervalT


-- | Concrete semantics of PCF.
module ConcreteInterpreter
data Closure
Closure :: Expr -> HashMap Text Val -> Closure
data Val
NumVal :: Int -> Val
ClosureVal :: Closure -> Val

-- | The concrete interpreter function for PCF. The function is implemented
--   by instantiating the shared semantics with the concrete interpreter
--   arrow <tt>Interp</tt>.
evalConcrete :: [(Text, Val)] -> State Label Expr -> Error String Val

-- | Arrow transformer that implements the concrete value semantics
newtype ConcreteT c x y
ConcreteT :: c x y -> ConcreteT c x y
[runConcreteT] :: ConcreteT c x y -> c x y
instance Control.Arrow.Fail.ArrowFail e c => Control.Arrow.Fail.ArrowFail e (ConcreteInterpreter.ConcreteT c)
instance Control.Arrow.ArrowChoice c => Control.Arrow.ArrowChoice (ConcreteInterpreter.ConcreteT c)
instance Control.Arrow.Arrow c => Control.Arrow.Arrow (ConcreteInterpreter.ConcreteT c)
instance Control.Category.Category c => Control.Category.Category (ConcreteInterpreter.ConcreteT c)
instance Data.Profunctor.Unsafe.Profunctor c => Data.Profunctor.Unsafe.Profunctor (ConcreteInterpreter.ConcreteT c)
instance GHC.Generics.Generic ConcreteInterpreter.Closure
instance GHC.Classes.Eq ConcreteInterpreter.Closure
instance GHC.Generics.Generic ConcreteInterpreter.Val
instance GHC.Classes.Eq ConcreteInterpreter.Val
instance Control.Arrow.Fix.ArrowFix x y c => Control.Arrow.Fix.ArrowFix x y (ConcreteInterpreter.ConcreteT c)
instance Control.Arrow.Environment.ArrowEnv var ConcreteInterpreter.Val env c => Control.Arrow.Environment.ArrowEnv var ConcreteInterpreter.Val env (ConcreteInterpreter.ConcreteT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Fail.ArrowFail GHC.Base.String c) => GenericInterpreter.IsNum ConcreteInterpreter.Val (ConcreteInterpreter.ConcreteT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Fail.ArrowFail GHC.Base.String c) => GenericInterpreter.IsClosure ConcreteInterpreter.Val (Data.HashMap.Base.HashMap Data.Text.Internal.Text ConcreteInterpreter.Val) (ConcreteInterpreter.ConcreteT c)
instance Data.Hashable.Class.Hashable ConcreteInterpreter.Closure
instance Data.Hashable.Class.Hashable ConcreteInterpreter.Val
instance GHC.Show.Show ConcreteInterpreter.Closure
instance GHC.Show.Show ConcreteInterpreter.Val

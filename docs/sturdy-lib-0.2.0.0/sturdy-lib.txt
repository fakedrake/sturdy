-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library for sound static analyses
--
--   A library for sound static analyses
@package sturdy-lib
@version 0.2.0.0

module Control.Arrow.Alloc

-- | Arrow-based interface for allocating addresses.
class (Arrow c, Profunctor c) => ArrowAlloc x y c

-- | Allocates a new address.
alloc :: ArrowAlloc x y c => c x y

module Control.Arrow.Conditional

-- | Arrow based interface to implement conditionals.
class (Arrow c, Profunctor c) => ArrowCond v c | c -> v where {

    -- | Type class constraint used by the abstract instances to join arrow
    --   computations.
    type family Join (c :: * -> * -> *) x y :: Constraint;
}

-- | <tt><a>if_</a> f g -&lt; (v,(x,y))</tt> performs a case distinction on
--   the given value <tt>v</tt> and executes either <tt>(f -&lt; x)</tt> or
--   <tt>(g -&lt; y)</tt>. Abstract instances might join the results of
--   <tt>f</tt> and <tt>g</tt>.
if_ :: (ArrowCond v c, Join c (x, y) z) => c x z -> c y z -> c (v, (x, y)) z

module Control.Arrow.Const

-- | Arrow-based interface that gives access to a constant value.
class (Arrow c, Profunctor c) => ArrowConst r c | c -> r

-- | Retrieve the constant value.
askConst :: ArrowConst r c => (r -> c x y) -> c x y

module Control.Arrow.Deduplicate

-- | Arrow-based interface to deduplicate the result <i>set</i> of a
--   computation. This is required by the <a>PowT</a> arrow transformer.
class (Arrow c, Profunctor c) => ArrowDeduplicate x y c
dedup :: ArrowDeduplicate x y c => c x y -> c x y
instance Control.Arrow.Deduplicate.ArrowDeduplicate x y (->)

module Control.Arrow.Except

-- | Arrow-based interface for exception handling.
class (Arrow c, Profunctor c) => ArrowExcept e c | c -> e where {

    -- | Type class constraint used by the abstract instances to join arrow
    --   computations.
    type family Join (c :: * -> * -> *) x y :: Constraint;
}

-- | Opertion that throws an exception that can be handled with
--   <a>catch</a>.
throw :: ArrowExcept e c => c e a

-- | <tt><a>try</a> f g h</tt> executes <tt>f</tt>, if it succeeds the
--   result is passed to <tt>g</tt>, if it fails the original input is
--   passed to <tt>h</tt>.
try :: (ArrowExcept e c, Join c (y, (x, e)) z) => c x y -> c y z -> c (x, e) z -> c x z

-- | Simpler version of <a>throw</a>.
throw' :: ArrowExcept () c => c a b
try' :: (Join c (y, (x, e)) z, ArrowExcept e c) => c x y -> c y z -> c x z -> c x z

-- | <tt><a>catch</a> f g</tt> handles exceptions thrown in <tt>f</tt> with
--   <tt>g</tt>.
catch :: (Join c (y, (x, e)) y, ArrowExcept e c) => c x y -> c (x, e) y -> c x y

-- | Simpler version of <a>catch</a>.
catch' :: (Join c (y, (x, e)) y, ArrowExcept e c) => c x y -> c e y -> c x y

-- | <tt><a>finally</a> f g</tt> executes <tt>g</tt>, no matter if
--   <tt>f</tt> throws an exception.
finally :: (Join c ((x, y), (x, e)) y, ArrowExcept e c) => c x y -> c x u -> c x y

-- | Picks the first computation that does not throw an exception.
(<+>) :: (Join c (y, (x, e)) y, ArrowExcept e c) => c x y -> c x y -> c x y

-- | <tt><a>tryFirst</a> f g -&lt; l</tt> executes <tt>f</tt> on elements
--   of <tt>l</tt> until one of them does not throw an exception. In case
--   <tt>f</tt> throws an exception for all elements of <tt>l</tt>,
--   <tt>g</tt> is executed.
tryFirst :: (Join c (y, ((x, [x]), e)) y, ArrowChoice c, ArrowExcept e c) => c x y -> c () y -> c [x] y

-- | A computation that always succeeds
success :: ArrowExcept e c => c a a

module Control.Arrow.Fail

-- | Arrow-based interface for computations that can fail.
class (Arrow c, Profunctor c) => ArrowFail e c | c -> e

-- | Causes the computation to fail. In contrast to <a>ArrowExcept</a>,
--   this failure cannot be recovered from.
fail :: ArrowFail e c => c e x

-- | Simpler version of <a>fail</a>.
fail' :: ArrowFail () c => c a b
instance Control.Monad.Error.Class.MonadError e m => Control.Arrow.Fail.ArrowFail e (Control.Arrow.Kleisli m)

module Control.Arrow.Monad
class (Functor f, Arrow c, Profunctor c, Arrow d, Profunctor d) => ArrowFunctor f c d
mapA :: ArrowFunctor f c d => c x y -> d (f x) (f y)
class (Monad f, ArrowFunctor f c c) => ArrowMonad f c
unitA :: ArrowMonad f c => c x (f x)
joinA :: ArrowMonad f c => c (f (f x)) (f x)
mapJoinA :: ArrowMonad f c => c x (f y) -> c (f x) (f y)

module Control.Arrow.Random
class (Arrow c, Profunctor c) => ArrowRand v c
random :: ArrowRand v c => c () v

module Control.Arrow.Reader

-- | Arrow-based interface for read-only values.
class (Arrow c, Profunctor c) => ArrowReader r c | c -> r

-- | Retrieves the current read-only value.
ask :: ArrowReader r c => c () r

-- | Runs a computation with a new value.
local :: ArrowReader r c => c x y -> c (r, x) y
instance Control.Monad.Reader.Class.MonadReader r m => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Kleisli m)

module Control.Arrow.State

-- | Arrow-based interface to describe stateful computations.
class (Arrow c, Profunctor c) => ArrowState s c | c -> s

-- | Retrieves the current state.
get :: ArrowState s c => c () s

-- | Sets the current state.
put :: ArrowState s c => c s ()

-- | Modifies the current state.
modify :: ArrowState s c => c (x, s) (y, s) -> c x y
modify' :: ArrowState s c => ((x, s) -> (y, s)) -> c x y

module Control.Arrow.Store

-- | Arrow-based interface to describe computations that read from a store.
--   The parameter <tt>y</tt> needs to be exposed, because abstract
--   instances may need to join on <tt>y</tt>.
class (Arrow c, Profunctor c) => ArrowStore var val c | c -> var, c -> val where {
    type family Join (c :: * -> * -> *) x y :: Constraint;
}

-- | Reads a value from the store. Fails if the binding is not in the
--   current store.
read :: (ArrowStore var val c, Join c ((val, x), x) y) => c (val, x) y -> c x y -> c (var, x) y

-- | Writes a value to the store.
write :: ArrowStore var val c => c (var, val) ()

-- | Simpler version of <a>read</a>
read' :: (Show var, Join c ((val, var), var) val, IsString e, ArrowFail e c, ArrowStore var val c) => c var val

module Control.Arrow.Trans
class ArrowLift t
lift' :: (ArrowLift t, Arrow c, Profunctor c) => c x y -> t c x y

-- | Lifts an inner computation into an arrow transformer and vice versa.
class ArrowTrans t where {
    type family Dom t x y :: *;
    type family Cod t x y :: *;
}
lift :: (ArrowTrans t, Arrow c, Profunctor c) => c (Dom t x y) (Cod t x y) -> t c x y
unlift :: (ArrowTrans t, Arrow c, Profunctor c) => t c x y -> c (Dom t x y) (Cod t x y)

module Control.Arrow.Fix

-- | Arrow-based interface for describing fixpoint computations.
class (Arrow c, Profunctor c) => ArrowFix x y c

-- | Computes the fixpoint of an arrow computation.
fix :: ArrowFix x y c => (c x y -> c x y) -> c x y
type family Fix x y (c :: * -> * -> *) :: * -> * -> *
liftFix :: (Arrow c, Profunctor c, ArrowFix (Dom t x y) (Cod t x y) c, ArrowTrans t) => (t c x y -> t c x y) -> t c x y
instance Control.Arrow.Fix.ArrowFix x y (->)

module Control.Arrow.Transformer.Concrete.Fixpoint

-- | Arrow transformer that computes the fixpoint in the concrete
--   interpreter.
data FixT a b c x y
runFixT :: FixT a b c x y -> c x y
instance Control.Arrow.ArrowChoice c => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Concrete.Fixpoint.FixT a b c)
instance Control.Arrow.Arrow c => Control.Arrow.Arrow (Control.Arrow.Transformer.Concrete.Fixpoint.FixT a b c)
instance Control.Category.Category c => Control.Category.Category (Control.Arrow.Transformer.Concrete.Fixpoint.FixT a b c)
instance Data.Profunctor.Unsafe.Profunctor c => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Concrete.Fixpoint.FixT a b c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Concrete.Fixpoint.FixT x y c)

module Control.Arrow.Utils

-- | Applies a computation to all elements of the input list and collects
--   the results in an list.
map :: ArrowChoice c => c x y -> c [x] [y]

-- | Throws away the result of a computation.
void :: Profunctor c => c x y -> c x ()
(&&>) :: (Arrow c, Profunctor c) => c a () -> c a b -> c a b
infixr 1 &&>

-- | Projects the first component of a product.
pi1 :: Arrow c => c (x, y) x

-- | Projects the second component of a product.
pi2 :: Arrow c => c (x, y) y

-- | Zips two lists together.
zipWith :: (ArrowChoice c, Profunctor c) => c (x, y) z -> c ([x], [y]) [z]

-- | Folds a computation over a list from left to right.
fold :: ArrowChoice c => c (a, x) a -> c ([x], a) a

-- | Duplicates the current value.
duplicate :: Arrow c => c x (x, x)

-- | creates a computation that always returns the same value.
const :: Profunctor c => c () x -> c y x

module Control.Arrow.Environment

-- | Arrow-based interface for interacting with environments.
class (Arrow c, Profunctor c) => ArrowEnv var val env c | c -> var, c -> val, c -> env where {

    -- | Type class constraint used by the abstract instances to join arrow
    --   computations.
    type family Join (c :: * -> * -> *) x y :: Constraint;
}

-- | Lookup a variable in the current environment. If the environment
--   contains a binding of the variable, the first continuation is called
--   and the second computation otherwise.
lookup :: (ArrowEnv var val env c, Join c ((val, x), x) y) => c (val, x) y -> c x y -> c (var, x) y

-- | Retrieve the current environment.
getEnv :: ArrowEnv var val env c => c () env

-- | Extend an environment with a binding.
extendEnv :: ArrowEnv var val env c => c (var, val, env) env

-- | Run a computation with a modified environment.
localEnv :: ArrowEnv var val env c => c x y -> c (env, x) y

-- | Simpler version of environment lookup.
lookup' :: (Join c ((val, var), var) val, Show var, IsString e, ArrowFail e c, ArrowEnv var val env c) => c var val
lookup'' :: (Join c ((val, var), var) y, Show var, IsString e, ArrowFail e c, ArrowEnv var val env c) => c val y -> c var y

-- | Run a computation in an extended environment.
extendEnv' :: ArrowEnv var val env c => c a b -> c (var, val, a) b

-- | Add a list of bindings to the given environment.
bindings :: (ArrowChoice c, ArrowEnv var val env c) => c ([(var, val)], env) env

module Control.Arrow.Writer
class (Arrow c, Profunctor c) => ArrowWriter w c | c -> w
tell :: ArrowWriter w c => c w ()

module Control.Arrow.Transformer.Cont
newtype ContT c x y
ContT :: (forall r. c y r -> c x r) -> ContT c x y
[runContT] :: ContT c x y -> forall r. c y r -> c x r
instance Data.Profunctor.Unsafe.Profunctor c => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Cont.ContT c)
instance Control.Category.Category (Control.Arrow.Transformer.Cont.ContT c)
instance Control.Arrow.ArrowApply c => Control.Arrow.Arrow (Control.Arrow.Transformer.Cont.ContT c)
instance (Control.Arrow.ArrowApply c, Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Cont.ContT c)
instance (Control.Arrow.ArrowApply c, Control.Arrow.Fix.ArrowFix x y c) => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Cont.ContT c)
instance Control.Arrow.Trans.ArrowTrans Control.Arrow.Transformer.Cont.ContT
instance Control.Arrow.Trans.ArrowLift Control.Arrow.Transformer.Cont.ContT
instance (Control.Arrow.ArrowApply c, Control.Arrow.State.ArrowState s c) => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Cont.ContT c)
instance (Control.Arrow.ArrowApply c, Control.Arrow.Reader.ArrowReader s c) => Control.Arrow.Reader.ArrowReader s (Control.Arrow.Transformer.Cont.ContT c)
instance (Control.Arrow.ArrowApply c, Control.Arrow.Writer.ArrowWriter w c) => Control.Arrow.Writer.ArrowWriter w (Control.Arrow.Transformer.Cont.ContT c)
instance (Control.Arrow.ArrowApply c, Control.Arrow.Fail.ArrowFail e c) => Control.Arrow.Fail.ArrowFail e (Control.Arrow.Transformer.Cont.ContT c)

module Data.Abstract.Stack
class IsStack stack a b
push :: IsStack stack a b => a -> stack a b -> stack a b
peek :: IsStack stack a b => stack a b -> Maybe a

module Data.Abstract.TreeGrammar.NonTerminal
class NonTerminal n where {
    type family Gen n :: *;
}
fresh :: NonTerminal n => Maybe String -> State (Gen n) n
generate :: forall (g :: * -> (* -> *) -> *) t. NonTerminal n => State (Gen n) (g n t) -> g n t
fresh' :: NonTerminal n => Maybe String -> State (Gen n, x) n
data Named
getName :: Named -> Text
instance GHC.Classes.Eq Data.Abstract.TreeGrammar.NonTerminal.Named
instance Data.Hashable.Class.Hashable Data.Abstract.TreeGrammar.NonTerminal.Named
instance GHC.Show.Show Data.Abstract.TreeGrammar.NonTerminal.Named
instance Data.Abstract.TreeGrammar.NonTerminal.NonTerminal Data.Abstract.TreeGrammar.NonTerminal.Named
instance Data.Abstract.TreeGrammar.NonTerminal.NonTerminal GHC.Types.Int

module Data.Boolean
class Logic b
true :: Logic b => b
false :: Logic b => b
and :: Logic b => b -> b -> b
or :: Logic b => b -> b -> b
not :: Logic b => b -> b
instance Data.Boolean.Logic GHC.Types.Bool

module Data.CallString
data CallString lab
CallString :: Seq lab -> Int -> Int -> CallString lab
[callString] :: CallString lab -> Seq lab
[size] :: CallString lab -> Int
[maxSize] :: CallString lab -> Int
empty :: Int -> CallString lab
push :: lab -> CallString lab -> CallString lab
resize :: CallString lab -> CallString lab
toList :: CallString lab -> [lab]
instance GHC.Show.Show lab => GHC.Show.Show (Data.CallString.CallString lab)
instance GHC.Classes.Eq lab => GHC.Classes.Eq (Data.CallString.CallString lab)
instance Data.Hashable.Class.Hashable lab => Data.Hashable.Class.Hashable (Data.CallString.CallString lab)

module Data.Concrete.Boolean
data Bool
False :: Bool
True :: Bool

module Data.Concrete.Error
data Error e x
Fail :: e -> Error e x
Success :: x -> Error e x
toEither :: Error e x -> Either e x
instance GHC.Base.Functor (Data.Concrete.Error.Error e)
instance (GHC.Classes.Eq e, GHC.Classes.Eq x) => GHC.Classes.Eq (Data.Concrete.Error.Error e x)
instance GHC.Base.Applicative (Data.Concrete.Error.Error e)
instance GHC.Base.Monad (Data.Concrete.Error.Error e)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Monad.ArrowFunctor (Data.Concrete.Error.Error e) c c
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Monad.ArrowMonad (Data.Concrete.Error.Error e) c
instance (GHC.Show.Show e, GHC.Show.Show a) => GHC.Show.Show (Data.Concrete.Error.Error e a)
instance (Data.Hashable.Class.Hashable e, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Data.Concrete.Error.Error e a)

module Data.Empty
class IsEmpty a
empty :: IsEmpty a => a
instance (Data.Empty.IsEmpty a, Data.Empty.IsEmpty b) => Data.Empty.IsEmpty (a, b)

module Data.Identifiable
type Identifiable a = (Eq a, Hashable a)

module Data.Lens
type Optic p s t a b = p a b -> p s t
type Iso s t a b = forall p. Profunctor p => Optic p s t a b
iso :: (s -> a) -> (b -> t) -> Iso s t a b
type Iso' a b = Iso a a b b
iso' :: (a -> b) -> (b -> a) -> Iso' a b
type Lens s t a b = forall p. Strong p => Optic p s t a b
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b
_1 :: Lens (a, c) (b, c) a b
_2 :: Lens (c, a) (c, b) a b
type Lens' a b = Lens a a b b
lens' :: (a -> b) -> (a -> b -> a) -> Lens' a b
type Prism s t a b = forall p. Choice p => Optic p s t a b
prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b
type Prism' a b = Prism a a b b
prism' :: (b -> a) -> (a -> Maybe b) -> Prism' a b
head :: Prism' [a] (a, [a])
type Getter r s t a b = Optic (Star (Const r)) s t a b
get :: Getter a s t a b -> s -> a
getMaybe :: Getter (First a) s t a b -> s -> Maybe a
type Setter s t a b = Optic (Star Identity) s t a b
set :: Setter s t a b -> b -> s -> t
second :: Optic (SecondT e p) s t a b -> Optic p (e, s) (e, t) (e, a) (e, b)
first :: Optic (FirstT e p) s t a b -> Optic p (s, e) (t, e) (a, e) (b, e)
newtype FirstT u c x y
FirstT :: c (x, u) (y, u) -> FirstT u c x y
[runFirstT] :: FirstT u c x y -> c (x, u) (y, u)
newtype SecondT u c x y
SecondT :: c (u, x) (u, y) -> SecondT u c x y
[runSecondT] :: SecondT u c x y -> c (u, x) (u, y)

-- | Due to
--   <a>https://hackage.haskell.org/package/lens-4.17/docs/src/Control.Lens.Internal.Iso.html</a>
data Exchange a b s t
Exchange :: (s -> a) -> (b -> t) -> Exchange a b s t
withIso :: Iso s t a b -> ((s -> a) -> (b -> t) -> r) -> r
from :: Iso s t a b -> Iso b a t s
instance Data.Profunctor.Unsafe.Profunctor (Data.Lens.Exchange a b)
instance Data.Profunctor.Unsafe.Profunctor c => Data.Profunctor.Unsafe.Profunctor (Data.Lens.SecondT u c)
instance Data.Profunctor.Strong.Strong c => Data.Profunctor.Strong.Strong (Data.Lens.SecondT u c)
instance Data.Profunctor.Choice.Choice c => Data.Profunctor.Choice.Choice (Data.Lens.SecondT u c)
instance Data.Profunctor.Unsafe.Profunctor c => Data.Profunctor.Unsafe.Profunctor (Data.Lens.FirstT u c)
instance Data.Profunctor.Strong.Strong c => Data.Profunctor.Strong.Strong (Data.Lens.FirstT u c)
instance Data.Profunctor.Choice.Choice c => Data.Profunctor.Choice.Choice (Data.Lens.FirstT u c)

module Data.Monoidal
class Monoidal m
mmap :: Monoidal m => (a -> a') -> (b -> b') -> (a `m` b) -> a' `m` b'
assoc1 :: Monoidal m => (a `m` (b `m` c)) -> (a `m` b) `m` c
assoc2 :: Monoidal m => ((a `m` b) `m` c) -> a `m` (b `m` c)
assoc :: Monoidal m => Iso' (a `m` (b `m` c)) ((a `m` b) `m` c)
class Strong f m
strength1 :: Strong f m => (f a `m` b) -> f (a `m` b)
strength2 :: Strong f m => (a `m` f b) -> f (a `m` b)
commute' :: Symmetric m => Iso' (a `m` b) (b `m` a)
class Monoidal m => Symmetric m
commute :: Symmetric m => (a `m` b) -> b `m` a
class Distributive m n
distribute1 :: Distributive m n => (a `m` (b `n` c)) -> (a `m` b) `n` (a `m` c)
distribute2 :: Distributive m n => ((a `m` b) `n` (a `m` c)) -> a `m` (b `n` c)
distribute :: Distributive m n => Iso' (a `m` (b `n` c)) ((a `m` b) `n` (a `m` c))
instance Data.Monoidal.Distributive (,) Data.Either.Either
instance Data.Monoidal.Symmetric (,)
instance Data.Monoidal.Symmetric Data.Either.Either
instance GHC.Base.Functor f => Data.Monoidal.Strong f (,)
instance GHC.Base.Applicative f => Data.Monoidal.Strong f Data.Either.Either
instance Data.Monoidal.Monoidal (,)
instance Data.Monoidal.Monoidal Data.Either.Either

module Control.Arrow.Transformer.Kleisli
newtype KleisliT f c x y
KleisliT :: c x (f y) -> KleisliT f c x y
[runKleisliT] :: KleisliT f c x y -> c x (f y)
instance Control.Arrow.Trans.ArrowTrans (Control.Arrow.Transformer.Kleisli.KleisliT f)
instance GHC.Base.Monad f => Control.Arrow.Trans.ArrowLift (Control.Arrow.Transformer.Kleisli.KleisliT f)
instance Control.Arrow.Monad.ArrowMonad f c => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Kleisli.KleisliT f c)
instance Control.Arrow.Monad.ArrowMonad f c => Control.Category.Category (Control.Arrow.Transformer.Kleisli.KleisliT f c)
instance Control.Arrow.Monad.ArrowMonad f c => Control.Arrow.Arrow (Control.Arrow.Transformer.Kleisli.KleisliT f c)
instance (Control.Arrow.Monad.ArrowMonad f c, Control.Arrow.ArrowChoice c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Kleisli.KleisliT f c)
instance (Control.Arrow.Monad.ArrowMonad f c, Control.Arrow.ArrowApply c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Kleisli.KleisliT f c)
instance (Control.Arrow.Monad.ArrowMonad f c, Control.Arrow.State.ArrowState s c) => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Kleisli.KleisliT f c)
instance (Control.Arrow.Monad.ArrowMonad f c, Control.Arrow.Reader.ArrowReader r c) => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.Kleisli.KleisliT f c)
instance (Control.Arrow.Monad.ArrowMonad f c, Control.Arrow.Environment.ArrowEnv x y env c) => Control.Arrow.Environment.ArrowEnv x y env (Control.Arrow.Transformer.Kleisli.KleisliT f c)
instance (Control.Arrow.Monad.ArrowMonad f c, Control.Arrow.Store.ArrowStore var val c) => Control.Arrow.Store.ArrowStore var val (Control.Arrow.Transformer.Kleisli.KleisliT f c)
instance (Control.Arrow.Monad.ArrowMonad f c, Control.Arrow.Fix.ArrowFix (Control.Arrow.Trans.Dom (Control.Arrow.Transformer.Kleisli.KleisliT f) x y) (Control.Arrow.Trans.Cod (Control.Arrow.Transformer.Kleisli.KleisliT f) x y) c) => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Kleisli.KleisliT f c)
instance (Control.Arrow.Monad.ArrowMonad f c, Control.Arrow.Except.ArrowExcept e c) => Control.Arrow.Except.ArrowExcept e (Control.Arrow.Transformer.Kleisli.KleisliT f c)
instance (Control.Arrow.Monad.ArrowMonad f c, Control.Arrow.Fail.ArrowFail e c) => Control.Arrow.Fail.ArrowFail e (Control.Arrow.Transformer.Kleisli.KleisliT f c)
instance (Data.Identifiable.Identifiable (f y), Control.Arrow.Monad.ArrowMonad f c, Control.Arrow.Arrow c, Control.Arrow.Deduplicate.ArrowDeduplicate (Control.Arrow.Trans.Dom (Control.Arrow.Transformer.Kleisli.KleisliT f) x y) (Control.Arrow.Trans.Cod (Control.Arrow.Transformer.Kleisli.KleisliT f) x y) c) => Control.Arrow.Deduplicate.ArrowDeduplicate x y (Control.Arrow.Transformer.Kleisli.KleisliT f c)
instance (Control.Arrow.Monad.ArrowMonad f c, Control.Arrow.Const.ArrowConst r c) => Control.Arrow.Const.ArrowConst r (Control.Arrow.Transformer.Kleisli.KleisliT f c)

module Control.Arrow.Transformer.Concrete.Failure

-- | Arrow transformer that adds failure to the result of a computation
data FailureT e c x y
runFailureT :: FailureT e c x y -> c x (Error e y)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Concrete.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Concrete.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Concrete.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Concrete.Failure.FailureT e c)
instance Control.Arrow.Trans.ArrowTrans (Control.Arrow.Transformer.Concrete.Failure.FailureT e)
instance Control.Arrow.Trans.ArrowLift (Control.Arrow.Transformer.Concrete.Failure.FailureT e)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.State.ArrowState s c) => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Concrete.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Reader.ArrowReader r c) => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.Concrete.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Environment.ArrowEnv x y env c) => Control.Arrow.Environment.ArrowEnv x y env (Control.Arrow.Transformer.Concrete.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Store.ArrowStore var val c) => Control.Arrow.Store.ArrowStore var val (Control.Arrow.Transformer.Concrete.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Except.ArrowExcept e c) => Control.Arrow.Except.ArrowExcept e (Control.Arrow.Transformer.Concrete.Failure.FailureT e' c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Fix.ArrowFix (Control.Arrow.Trans.Dom (Control.Arrow.Transformer.Concrete.Failure.FailureT e) x y) (Control.Arrow.Trans.Cod (Control.Arrow.Transformer.Concrete.Failure.FailureT e) x y) c) => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Concrete.Failure.FailureT e c)
instance (Data.Identifiable.Identifiable (Data.Concrete.Error.Error e y), Control.Arrow.ArrowChoice c, Control.Arrow.Deduplicate.ArrowDeduplicate x (Data.Concrete.Error.Error e y) c) => Control.Arrow.Deduplicate.ArrowDeduplicate x y (Control.Arrow.Transformer.Concrete.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Const.ArrowConst r c) => Control.Arrow.Const.ArrowConst r (Control.Arrow.Transformer.Concrete.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Fail.ArrowFail e (Control.Arrow.Transformer.Concrete.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.ArrowApply c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Concrete.Failure.FailureT e c)

module Control.Arrow.Transformer.Concrete.Except

-- | Arrow transformer that adds exceptions to the result of a computation
data ExceptT e c x y
runExceptT :: ExceptT e c x y -> c x (Error e y)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Concrete.Except.ExceptT e c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Concrete.Except.ExceptT e c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Concrete.Except.ExceptT e c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Concrete.Except.ExceptT e c)
instance Control.Arrow.Trans.ArrowTrans (Control.Arrow.Transformer.Concrete.Except.ExceptT e)
instance Control.Arrow.Trans.ArrowLift (Control.Arrow.Transformer.Concrete.Except.ExceptT e)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.State.ArrowState s c) => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Concrete.Except.ExceptT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Fail.ArrowFail f c) => Control.Arrow.Fail.ArrowFail f (Control.Arrow.Transformer.Concrete.Except.ExceptT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Reader.ArrowReader r c) => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.Concrete.Except.ExceptT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Environment.ArrowEnv x y env c) => Control.Arrow.Environment.ArrowEnv x y env (Control.Arrow.Transformer.Concrete.Except.ExceptT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Store.ArrowStore var val c) => Control.Arrow.Store.ArrowStore var val (Control.Arrow.Transformer.Concrete.Except.ExceptT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Fix.ArrowFix (Control.Arrow.Trans.Dom (Control.Arrow.Transformer.Concrete.Except.ExceptT e) x y) (Control.Arrow.Trans.Cod (Control.Arrow.Transformer.Concrete.Except.ExceptT e) x y) c) => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Concrete.Except.ExceptT e c)
instance (Data.Identifiable.Identifiable (Data.Concrete.Error.Error e y), Control.Arrow.ArrowChoice c, Control.Arrow.Deduplicate.ArrowDeduplicate x (Data.Concrete.Error.Error e y) c) => Control.Arrow.Deduplicate.ArrowDeduplicate x y (Control.Arrow.Transformer.Concrete.Except.ExceptT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Const.ArrowConst r c) => Control.Arrow.Const.ArrowConst r (Control.Arrow.Transformer.Concrete.Except.ExceptT e c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Except.ArrowExcept e (Control.Arrow.Transformer.Concrete.Except.ExceptT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.ArrowApply c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Concrete.Except.ExceptT e c)

module Data.Numeric
class Num n => Numeric n f | n -> f
(/) :: Numeric n f => n -> n -> f n
infixl 7 /

module Data.Order

-- | Reflexive, transitive order
class PreOrd x
(⊑) :: PreOrd x => x -> x -> Bool
(≈) :: PreOrd x => x -> x -> Bool
infix 4 ≈
infix 4 ⊑

-- | Order with all least upper bounds
class PreOrd x => Complete x
(⊔) :: Complete x => x -> x -> x
infixr 5 ⊔

-- | Order with a least element
class PreOrd x => LowerBounded x
bottom :: LowerBounded x => x
lub :: (Foldable f, Complete x) => f x -> x
joined :: (Arrow c, Profunctor c, Complete (c (a1, a2) b)) => c a1 b -> c a2 b -> c (a1, a2) b

-- | <i>Deprecated: Use Control.Arrow.Abstract.ArrowJoin.joinList</i>
lubA :: (ArrowChoice c, Profunctor c, Complete (c (x, [x]) y), LowerBounded (c () y)) => c x y -> c [x] y

-- | Order with all greatest lower bounds
class PreOrd x => CoComplete x
(⊓) :: CoComplete x => x -> x -> x
infix 5 ⊓

-- | Order with a greatest element
class PreOrd x => UpperBounded x
top :: UpperBounded x => x
glb :: (Foldable f, CoComplete x) => f x -> x
instance Data.Order.UpperBounded ()
instance (Data.Order.UpperBounded a, Data.Order.UpperBounded b) => Data.Order.UpperBounded (a, b)
instance (Data.Order.UpperBounded a, Data.Order.UpperBounded b, Data.Order.UpperBounded c) => Data.Order.UpperBounded (a, b, c)
instance Data.Order.UpperBounded b => Data.Order.UpperBounded (a -> b)
instance (GHC.Classes.Ord a, Data.Order.PreOrd a) => Data.Order.CoComplete (Data.Set.Internal.Set a)
instance (Data.Order.CoComplete a, Data.Order.CoComplete b) => Data.Order.CoComplete (a, b)
instance (Data.Order.CoComplete a, Data.Order.CoComplete b, Data.Order.CoComplete c) => Data.Order.CoComplete (a, b, c)
instance Data.Order.CoComplete b => Data.Order.CoComplete (a -> b)
instance Data.Order.LowerBounded ()
instance (Data.Order.LowerBounded a, Data.Order.LowerBounded b) => Data.Order.LowerBounded (a, b)
instance (Data.Order.LowerBounded a, Data.Order.LowerBounded b, Data.Order.LowerBounded c) => Data.Order.LowerBounded (a, b, c)
instance Data.Order.LowerBounded b => Data.Order.LowerBounded (a -> b)
instance Data.Order.PreOrd a => Data.Order.LowerBounded (GHC.Maybe.Maybe a)
instance Data.Order.PreOrd a => Data.Order.LowerBounded (Data.Set.Internal.Set a)
instance (GHC.Classes.Ord k, Data.Order.PreOrd v) => Data.Order.LowerBounded (Data.Map.Internal.Map k v)
instance Data.Order.LowerBounded (m b) => Data.Order.LowerBounded (Control.Arrow.Kleisli m a b)
instance Data.Order.LowerBounded a => Data.Order.LowerBounded (Data.Functor.Identity.Identity a)
instance (GHC.Classes.Ord a, Data.Order.PreOrd a) => Data.Order.Complete (Data.Set.Internal.Set a)
instance Data.Order.Complete ()
instance (Data.Order.Complete a, Data.Order.Complete b) => Data.Order.Complete (a, b)
instance (Data.Order.Complete a, Data.Order.Complete b, Data.Order.Complete c) => Data.Order.Complete (a, b, c)
instance Data.Order.Complete b => Data.Order.Complete (a -> b)
instance (GHC.Classes.Ord k, Data.Order.Complete v) => Data.Order.Complete (Data.Map.Internal.Map k v)
instance Data.Order.Complete a => Data.Order.Complete (GHC.Maybe.Maybe a)
instance Data.Identifiable.Identifiable a => Data.Order.Complete (Data.HashSet.Base.HashSet a)
instance Data.Order.Complete (m b) => Data.Order.Complete (Control.Arrow.Kleisli m a b)
instance Data.Order.Complete a => Data.Order.Complete (Data.Functor.Identity.Identity a)
instance (Data.Order.PreOrd e, Data.Order.PreOrd a) => Data.Order.PreOrd (Data.Either.Either e a)
instance Data.Order.PreOrd a => Data.Order.PreOrd [a]
instance Data.Order.PreOrd a => Data.Order.PreOrd (Data.Set.Internal.Set a)
instance Data.Order.PreOrd ()
instance (Data.Order.PreOrd a, Data.Order.PreOrd b) => Data.Order.PreOrd (a, b)
instance (Data.Order.PreOrd a, Data.Order.PreOrd b, Data.Order.PreOrd c) => Data.Order.PreOrd (a, b, c)
instance Data.Order.PreOrd b => Data.Order.PreOrd (a -> b)
instance (GHC.Classes.Ord k, Data.Order.PreOrd v) => Data.Order.PreOrd (Data.Map.Internal.Map k v)
instance Data.Order.PreOrd v => Data.Order.PreOrd (Data.IntMap.Internal.IntMap v)
instance Data.Order.PreOrd GHC.Types.Char
instance Data.Order.PreOrd Data.Text.Internal.Text
instance Data.Order.PreOrd GHC.Types.Int
instance Data.Order.PreOrd GHC.Types.Double
instance Data.Order.PreOrd a => Data.Order.PreOrd (GHC.Maybe.Maybe a)
instance Data.Identifiable.Identifiable a => Data.Order.PreOrd (Data.HashSet.Base.HashSet a)
instance (Data.Identifiable.Identifiable a, Data.Order.PreOrd b) => Data.Order.PreOrd (Data.HashMap.Base.HashMap a b)
instance Data.Order.PreOrd (m b) => Data.Order.PreOrd (Control.Arrow.Kleisli m a b)
instance Data.Order.PreOrd a => Data.Order.PreOrd (Data.Functor.Identity.Identity a)

module Data.Concrete.Powerset
newtype Pow a
Pow :: Seq a -> Pow a
empty :: Pow a
singleton :: a -> Pow a
union :: Pow a -> Pow a -> Pow a
cartesian :: (Pow a, Pow b) -> Pow (a, b)
toHashSet :: Identifiable a => Pow a -> HashSet a
fromFoldable :: (Foldable f, Monad t, Monoid (t a)) => f a -> t a
size :: Foldable f => f a -> Int
dedup :: Identifiable a => Pow a -> Pow a
powmap :: (a -> b) -> Pow a -> Pow b
unions :: Pow (Pow a) -> Pow a
instance GHC.Generics.Generic (Data.Concrete.Powerset.Pow a)
instance Data.Traversable.Traversable Data.Concrete.Powerset.Pow
instance Data.Foldable.Foldable Data.Concrete.Powerset.Pow
instance GHC.Base.Monoid (Data.Concrete.Powerset.Pow a)
instance GHC.Base.Semigroup (Data.Concrete.Powerset.Pow a)
instance GHC.Base.MonadPlus Data.Concrete.Powerset.Pow
instance GHC.Base.Alternative Data.Concrete.Powerset.Pow
instance GHC.Base.Monad Data.Concrete.Powerset.Pow
instance GHC.Base.Applicative Data.Concrete.Powerset.Pow
instance GHC.Base.Functor Data.Concrete.Powerset.Pow
instance Data.Identifiable.Identifiable a => Data.Order.PreOrd (Data.Concrete.Powerset.Pow a)
instance Data.Identifiable.Identifiable a => Data.Order.LowerBounded (Data.Concrete.Powerset.Pow a)
instance Data.Identifiable.Identifiable a => GHC.Classes.Eq (Data.Concrete.Powerset.Pow a)
instance Data.Identifiable.Identifiable a => Data.Order.Complete (Data.Concrete.Powerset.Pow a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Concrete.Powerset.Pow a)
instance Data.Identifiable.Identifiable a => Data.Hashable.Class.Hashable (Data.Concrete.Powerset.Pow a)
instance GHC.Exts.IsList (Data.Concrete.Powerset.Pow a)

module Data.Abstract.Widening

-- | ▽ has to be an upper bound operator, i.e. x ⊑ x ▽ y and y ⊑ x ▽ y.
--   Furthermore, iterating ▽ on an ascending chain has to stabilize: Let
--   x1, x2, ... xn be an infinite ascending chain, then x1, x1 ▽ x2, (x1 ▽
--   x2) ▽ x3, ... (similar to left fold) has a limit:
--
--   ... finite ▽ / ▽ / ▽ / x1 ⊑ x2 ⊑ x3 ⊑ x4 ⊑ ... infinite
--
--   Furthermore, we allow our widening operators to maintain some state
--   between each iteration.
type Widening a = a -> a -> (Stable, a)

-- | Datatype that signals if the ascending chain stabilized.
data Stable
Stable :: Stable
Instable :: Stable

-- | For a preorder with no infinite ascending chains, (⊔) is a trivial
--   widening operator.
finite :: Complete a => Widening a
toJoin :: (Widening a -> Widening b) -> (a -> a -> a) -> b -> b -> b
toJoin2 :: (Widening a -> Widening b -> Widening c) -> (a -> a -> a) -> (b -> b -> b) -> c -> c -> c

-- | Widening operator that joins until the given limit is reached. Then it
--   calls the fallback widening operator.
bounded :: Complete a => a -> Widening a -> Widening a
(**) :: Widening a -> Widening b -> Widening (a, b)
instance GHC.Show.Show Data.Abstract.Widening.Stable
instance GHC.Classes.Eq Data.Abstract.Widening.Stable
instance GHC.Base.Semigroup Data.Abstract.Widening.Stable
instance GHC.Base.Monoid Data.Abstract.Widening.Stable
instance Data.Order.PreOrd Data.Abstract.Widening.Stable
instance Data.Order.Complete Data.Abstract.Widening.Stable

module Control.Arrow.Abstract.Cache
class (Profunctor c, Arrow c) => ArrowCache a b c
lookup :: ArrowCache a b c => c a b
update :: ArrowCache a b c => c (a, b) (Stable, b)
cached :: ArrowCache a b c => c a b -> c a b

module Data.Abstract.There

-- | Datatype that indicates if a value in the map must be there or may not
--   be there.
data There
Must :: There
May :: There
widening :: Widening There
may :: a -> (There, a)
must :: a -> (There, a)
instance Control.DeepSeq.NFData Data.Abstract.There.There
instance GHC.Generics.Generic Data.Abstract.There.There
instance GHC.Classes.Eq Data.Abstract.There.There
instance GHC.Show.Show Data.Abstract.There.There
instance Data.Order.PreOrd Data.Abstract.There.There
instance Data.Order.Complete Data.Abstract.There.There
instance Data.Hashable.Class.Hashable Data.Abstract.There.There

module Data.Abstract.Terminating
data Terminating a
NonTerminating :: Terminating a
Terminating :: a -> Terminating a
widening :: Widening a -> Widening (Terminating a)
fromTerminating :: a -> Terminating a -> a
toMaybe :: Terminating a -> Maybe a
toEither :: Terminating a -> Either () a
instance GHC.Generics.Generic (Data.Abstract.Terminating.Terminating a)
instance Data.Foldable.Foldable Data.Abstract.Terminating.Terminating
instance Data.Traversable.Traversable Data.Abstract.Terminating.Terminating
instance GHC.Base.Functor Data.Abstract.Terminating.Terminating
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Abstract.Terminating.Terminating a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Abstract.Terminating.Terminating a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Abstract.Terminating.Terminating a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.Abstract.Terminating.Terminating a)
instance GHC.Base.Applicative Data.Abstract.Terminating.Terminating
instance GHC.Base.Monad Data.Abstract.Terminating.Terminating
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Monad.ArrowFunctor Data.Abstract.Terminating.Terminating c c
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Monad.ArrowMonad Data.Abstract.Terminating.Terminating c
instance Data.Order.PreOrd a => Data.Order.PreOrd (Data.Abstract.Terminating.Terminating a)
instance Data.Order.Complete a => Data.Order.Complete (Data.Abstract.Terminating.Terminating a)
instance Data.Order.CoComplete a => Data.Order.CoComplete (Data.Abstract.Terminating.Terminating a)
instance Data.Order.UpperBounded a => Data.Order.UpperBounded (Data.Abstract.Terminating.Terminating a)
instance Data.Order.PreOrd a => Data.Order.LowerBounded (Data.Abstract.Terminating.Terminating a)
instance GHC.Num.Num a => GHC.Num.Num (Data.Abstract.Terminating.Terminating a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Abstract.Terminating.Terminating a)

module Data.Abstract.Powerset
newtype Pow a
Pow :: Seq a -> Pow a
toEither :: Pow a -> Either () (a, Pow a)
empty :: Pow a
singleton :: a -> Pow a
insert :: a -> Pow a -> Pow a
union :: Pow a -> Pow a -> Pow a
toHashSet :: (Hashable a, Eq a) => Pow a -> HashSet a
fromFoldable :: (Foldable f, Monad t, Monoid (t a)) => f a -> t a
size :: Foldable f => f a -> Int
dedup :: (Hashable a, Eq a) => Pow a -> Pow a
instance GHC.Generics.Generic (Data.Abstract.Powerset.Pow a)
instance Data.Traversable.Traversable Data.Abstract.Powerset.Pow
instance Data.Foldable.Foldable Data.Abstract.Powerset.Pow
instance GHC.Base.Monoid (Data.Abstract.Powerset.Pow a)
instance GHC.Base.Semigroup (Data.Abstract.Powerset.Pow a)
instance GHC.Base.MonadPlus Data.Abstract.Powerset.Pow
instance GHC.Base.Alternative Data.Abstract.Powerset.Pow
instance GHC.Base.Monad Data.Abstract.Powerset.Pow
instance GHC.Base.Applicative Data.Abstract.Powerset.Pow
instance GHC.Base.Functor Data.Abstract.Powerset.Pow
instance Data.Order.PreOrd a => Data.Order.PreOrd (Data.Abstract.Powerset.Pow a)
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => GHC.Classes.Eq (Data.Abstract.Powerset.Pow a)
instance Data.Order.PreOrd a => Data.Order.Complete (Data.Abstract.Powerset.Pow a)
instance Data.Order.PreOrd a => Data.Order.LowerBounded (Data.Abstract.Powerset.Pow a)
instance Data.Order.UpperBounded a => Data.Order.UpperBounded (Data.Abstract.Powerset.Pow a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Abstract.Powerset.Pow a)
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Data.Abstract.Powerset.Pow a)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Monad.ArrowFunctor Data.Abstract.Powerset.Pow c c
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Monad.ArrowMonad Data.Abstract.Powerset.Pow c

module Data.Abstract.Narrowing
class PreOrd a => Narrowing a

-- | For △ holds that, i.e. if x ⊑ y then y ⊑ x ▽ y ⊑ x. Furthermore,
--   iterating ▽ on an descending chain has to stabilize: Let x1, x2, ...
--   xn be an infinite descending chain, then x1, x1 ▽ x2, (x1 ▽ x2) ▽ x3,
--   ... has a limit. Notice that widening and narrowing are *not* dual.
(△) :: Narrowing a => a -> a -> a

module Data.Abstract.Maybe

-- | Abstract <a>Maybe</a> type with an upper bound for <a>Just</a> and
--   <a>Nothing</a>
data Maybe a
Just :: a -> Maybe a
Nothing :: Maybe a
JustNothing :: a -> Maybe a
widening :: Widening a -> Widening (Maybe a)
fromConcreteMaybe :: Maybe a -> Maybe a
instance GHC.Generics.Generic (Data.Abstract.Maybe.Maybe a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Abstract.Maybe.Maybe a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Abstract.Maybe.Maybe a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Abstract.Maybe.Maybe a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Abstract.Maybe.Maybe a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.Abstract.Maybe.Maybe a)
instance Data.Order.PreOrd a => Data.Order.PreOrd (Data.Abstract.Maybe.Maybe a)
instance Data.Order.Complete a => Data.Order.Complete (Data.Abstract.Maybe.Maybe a)
instance Data.Order.UpperBounded a => Data.Order.UpperBounded (Data.Abstract.Maybe.Maybe a)
instance GHC.Base.Functor Data.Abstract.Maybe.Maybe
instance GHC.Base.Applicative Data.Abstract.Maybe.Maybe
instance GHC.Base.Monad Data.Abstract.Maybe.Maybe
instance Data.Foldable.Foldable Data.Abstract.Maybe.Maybe
instance Data.Traversable.Traversable Data.Abstract.Maybe.Maybe

module Data.Abstract.WeakMap
data Map a b
widening :: Identifiable a => Widening b -> Widening (Map a b)
empty :: Map a b
insert :: Identifiable a => a -> b -> Map a b -> Map a b
lookup :: Identifiable a => a -> b -> Map a b -> Maybe b
lookup' :: (Identifiable a, UpperBounded b) => a -> Map a b -> Maybe b
delete :: Identifiable a => a -> Map a b -> Map a b
delete' :: (Foldable f, Identifiable a) => f a -> Map a b -> Map a b
deleteIfNotPresent :: Identifiable a => a -> Map a b -> Map a b
deleteIfNotPresent' :: (Foldable f, Identifiable a) => f a -> Map a b -> Map a b
union :: (Identifiable a, Complete b) => Map a b -> Map a b -> Map a b
fromList :: Identifiable a => [(a, b)] -> Map a b
fromList' :: Identifiable a => [(a, Maybe b)] -> Map a b
toList :: Map a b -> [(a, b)]
dropNegativeBindings :: Identifiable a => Map a b -> Map a b
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (Data.Abstract.WeakMap.Map a b)
instance (Data.Hashable.Class.Hashable a, Data.Hashable.Class.Hashable b) => Data.Hashable.Class.Hashable (Data.Abstract.WeakMap.Map a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Data.Abstract.WeakMap.Map a b)
instance (Data.Identifiable.Identifiable a, Data.Order.PreOrd b) => Data.Order.PreOrd (Data.Abstract.WeakMap.Map a b)
instance (Data.Identifiable.Identifiable a, Data.Order.Complete b) => Data.Order.Complete (Data.Abstract.WeakMap.Map a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Abstract.WeakMap.Map a b)

module Data.Abstract.StrongMap
data Map a b
widening :: Identifiable a => Widening b -> Widening (Map a b)
empty :: Map a b
insert :: Identifiable a => a -> b -> Map a b -> Map a b
lookup :: Identifiable a => a -> b -> Map a b -> Maybe b
lookup' :: (Identifiable a, UpperBounded b) => a -> Map a b -> Maybe b
fromList :: Identifiable a => [(a, b)] -> Map a b
toList :: Map a b -> Maybe [(a, b)]
instance GHC.Generics.Generic (Data.Abstract.StrongMap.Map a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Data.Abstract.StrongMap.Map a b)
instance (Data.Identifiable.Identifiable a, Data.Order.PreOrd b) => Data.Order.PreOrd (Data.Abstract.StrongMap.Map a b)
instance (Data.Identifiable.Identifiable a, Data.Order.Complete b) => Data.Order.Complete (Data.Abstract.StrongMap.Map a b)
instance (Data.Hashable.Class.Hashable a, Data.Hashable.Class.Hashable b) => Data.Hashable.Class.Hashable (Data.Abstract.StrongMap.Map a b)
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (Data.Abstract.StrongMap.Map a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Abstract.StrongMap.Map a b)

module Data.Abstract.Map

-- | Abstract hashmap
data Map a b
singleton :: Identifiable a => a -> b -> Map a b
empty :: Map a b
lookup :: Identifiable a => a -> Map a b -> Maybe b
unsafeLookup :: Identifiable a => a -> Map a b -> Maybe b
insert :: Identifiable a => a -> b -> Map a b -> Map a b
insertWith :: (Identifiable a, Complete b) => (b -> b -> b) -> a -> b -> Map a b -> Map a b
unsafeInsertWith :: Identifiable a => (b -> b -> b) -> a -> b -> Map a b -> Map a b
unsafeInsertWithLookup :: Identifiable a => (b -> b -> b) -> a -> b -> Map a b -> (b, Map a b)
delete :: Identifiable a => a -> Map a b -> Map a b
delete' :: (Foldable f, Identifiable a) => f a -> Map a b -> Map a b
union :: (Identifiable a, Complete b) => Map a b -> Map a b -> Map a b
adjust :: Identifiable a => (b -> b) -> a -> Map a b -> Map a b

-- | The <a>toList</a> function extracts a list of <tt>Item l</tt> from the
--   structure <tt>l</tt>. It should satisfy fromList . toList = id.
toList :: IsList l => l -> [Item l]

-- | The <a>fromList</a> function constructs the structure <tt>l</tt> from
--   the given list of <tt>Item l</tt>
fromList :: IsList l => [Item l] -> l
mapMaybe :: (Identifiable a', Complete b') => ((a, b) -> Maybe (a', b')) -> Map a b -> Map a' b'
map :: (b -> b') -> Map a b -> Map a b'
compose :: (Identifiable a, Identifiable b, Complete c) => [(a, b)] -> Map b c -> Map a c
widening :: Identifiable a => Widening b -> Widening (Map a b)
fromThereList :: Identifiable a => [(a, (There, b))] -> Map a b
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (Data.Abstract.Map.Map a b)
instance (Data.Hashable.Class.Hashable a, Data.Hashable.Class.Hashable b) => Data.Hashable.Class.Hashable (Data.Abstract.Map.Map a b)
instance Data.Traversable.Traversable (Data.Abstract.Map.Map a)
instance Data.Foldable.Foldable (Data.Abstract.Map.Map a)
instance GHC.Base.Functor (Data.Abstract.Map.Map a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Data.Abstract.Map.Map a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Abstract.Map.Map a b)
instance (Data.Identifiable.Identifiable a, Data.Order.PreOrd b) => Data.Order.PreOrd (Data.Abstract.Map.Map a b)
instance (Data.Identifiable.Identifiable a, Data.Order.Complete b) => Data.Order.Complete (Data.Abstract.Map.Map a b)
instance (Data.Identifiable.Identifiable a, Data.Order.PreOrd b) => Data.Order.LowerBounded (Data.Abstract.Map.Map a b)
instance Data.Identifiable.Identifiable a => GHC.Exts.IsList (Data.Abstract.Map.Map a b)

module Data.Abstract.InfiniteNumbers
data InfiniteNumber a
NegInfinity :: InfiniteNumber a
Number :: a -> InfiniteNumber a
Infinity :: InfiniteNumber a
isNegative :: (Eq a, Num a) => a -> Bool
mult :: (Num a, Ord a) => a -> InfiniteNumber a -> InfiniteNumber a
divInf :: Integral n => InfiniteNumber n -> InfiniteNumber n -> InfiniteNumber n
instance GHC.Generics.Generic (Data.Abstract.InfiniteNumbers.InfiniteNumber a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Abstract.InfiniteNumbers.InfiniteNumber a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Abstract.InfiniteNumbers.InfiniteNumber a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Abstract.InfiniteNumbers.InfiniteNumber a)
instance (GHC.Num.Num a, GHC.Classes.Ord a) => GHC.Num.Num (Data.Abstract.InfiniteNumbers.InfiniteNumber a)
instance GHC.Classes.Ord a => Data.Order.PreOrd (Data.Abstract.InfiniteNumbers.InfiniteNumber a)
instance GHC.Classes.Ord a => Data.Order.LowerBounded (Data.Abstract.InfiniteNumbers.InfiniteNumber a)
instance GHC.Classes.Ord a => Data.Order.UpperBounded (Data.Abstract.InfiniteNumbers.InfiniteNumber a)
instance GHC.Classes.Ord a => Data.Order.Complete (Data.Abstract.InfiniteNumbers.InfiniteNumber a)
instance GHC.Classes.Ord a => Data.Order.CoComplete (Data.Abstract.InfiniteNumbers.InfiniteNumber a)
instance GHC.Enum.Bounded (Data.Abstract.InfiniteNumbers.InfiniteNumber n)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.Abstract.InfiniteNumbers.InfiniteNumber a)

module Data.Abstract.FreeCompletion
data FreeCompletion a
Lower :: a -> FreeCompletion a
Top :: FreeCompletion a
toEither :: FreeCompletion a -> Either () a
widening :: Widening a -> Widening (FreeCompletion a)
fromCompletion :: a -> FreeCompletion a -> a
instance GHC.Generics.Generic (Data.Abstract.FreeCompletion.FreeCompletion a)
instance Data.Foldable.Foldable Data.Abstract.FreeCompletion.FreeCompletion
instance Data.Traversable.Traversable Data.Abstract.FreeCompletion.FreeCompletion
instance GHC.Base.Functor Data.Abstract.FreeCompletion.FreeCompletion
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Abstract.FreeCompletion.FreeCompletion a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Abstract.FreeCompletion.FreeCompletion a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Abstract.FreeCompletion.FreeCompletion a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.Abstract.FreeCompletion.FreeCompletion a)
instance GHC.Base.Applicative Data.Abstract.FreeCompletion.FreeCompletion
instance GHC.Base.Monad Data.Abstract.FreeCompletion.FreeCompletion
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Monad.ArrowFunctor Data.Abstract.FreeCompletion.FreeCompletion c c
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Monad.ArrowMonad Data.Abstract.FreeCompletion.FreeCompletion c
instance Data.Order.PreOrd a => Data.Order.PreOrd (Data.Abstract.FreeCompletion.FreeCompletion a)
instance (Data.Order.PreOrd a, Data.Order.Complete (Data.Abstract.FreeCompletion.FreeCompletion a), Data.Order.PreOrd b, Data.Order.Complete (Data.Abstract.FreeCompletion.FreeCompletion b)) => Data.Order.Complete (Data.Abstract.FreeCompletion.FreeCompletion (a, b))
instance (Data.Order.PreOrd a, Data.Order.UpperBounded (Data.Abstract.FreeCompletion.FreeCompletion a), Data.Order.PreOrd b, Data.Order.UpperBounded (Data.Abstract.FreeCompletion.FreeCompletion b)) => Data.Order.UpperBounded (Data.Abstract.FreeCompletion.FreeCompletion (a, b))
instance (Data.Order.PreOrd x, Data.Order.Complete (Data.Abstract.FreeCompletion.FreeCompletion x)) => Data.Order.Complete (Data.Abstract.FreeCompletion.FreeCompletion [x])
instance Data.Order.Complete (Data.Abstract.FreeCompletion.FreeCompletion GHC.Types.Int)
instance Data.Order.Complete (Data.Abstract.FreeCompletion.FreeCompletion Data.Text.Internal.Text)
instance Data.Order.CoComplete a => Data.Order.CoComplete (Data.Abstract.FreeCompletion.FreeCompletion a)
instance Data.Order.LowerBounded a => Data.Order.LowerBounded (Data.Abstract.FreeCompletion.FreeCompletion a)
instance GHC.Num.Num a => GHC.Num.Num (Data.Abstract.FreeCompletion.FreeCompletion a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Abstract.FreeCompletion.FreeCompletion a)
instance Data.Order.Complete (Data.Abstract.FreeCompletion.FreeCompletion ())
instance Data.String.IsString s => Data.String.IsString (Data.Abstract.FreeCompletion.FreeCompletion s)

module Data.Label
class HasLabel x lab
label :: HasLabel x lab => x -> lab
newtype Label
Label :: Int -> Label
[labelVal] :: Label -> Int
fresh :: State Label Label
generate :: State Label x -> x
instance GHC.Num.Num Data.Label.Label
instance Data.Hashable.Class.Hashable Data.Label.Label
instance GHC.Classes.Eq Data.Label.Label
instance GHC.Classes.Ord Data.Label.Label
instance GHC.Show.Show Data.Label.Label
instance Data.Order.PreOrd Data.Label.Label
instance Data.Order.Complete (Data.Abstract.FreeCompletion.FreeCompletion Data.Label.Label)
instance Data.Order.UpperBounded (Data.Abstract.FreeCompletion.FreeCompletion Data.Label.Label)

module Data.Abstract.FiniteMap
newtype Map x addr y
Map :: (HashMap x addr, HashMap addr (There, y)) -> Map x addr y
widening :: (Identifiable x, Identifiable addr) => Widening y -> Widening (Map x addr y)
empty :: Map x addr y
keys :: Map x addr y -> [x]
lookup :: (Identifiable x, Identifiable addr) => x -> Map x addr y -> Maybe y
unsafeLookup :: (Identifiable x, Identifiable addr) => x -> Map x addr y -> Maybe y
insertBy :: (Identifiable x, Identifiable addr, Complete y, ArrowChoice c) => c (x, y, Map x addr y) addr -> c (x, y, Map x addr y) (Map x addr y)
insert :: (Identifiable x, Identifiable addr, Complete y, ArrowChoice c, ArrowAlloc (x, y, Map x addr y) addr c) => c (x, y, Map x addr y) (Map x addr y)
toList :: (Identifiable x, Identifiable addr) => Map x addr y -> [(x, y)]
instance (Data.Hashable.Class.Hashable x, Data.Hashable.Class.Hashable addr, Data.Hashable.Class.Hashable y) => Data.Hashable.Class.Hashable (Data.Abstract.FiniteMap.Map x addr y)
instance (GHC.Classes.Eq x, GHC.Classes.Eq addr, GHC.Classes.Eq y) => GHC.Classes.Eq (Data.Abstract.FiniteMap.Map x addr y)
instance (GHC.Show.Show x, GHC.Show.Show addr, GHC.Show.Show y) => GHC.Show.Show (Data.Abstract.FiniteMap.Map x addr y)
instance (Data.Identifiable.Identifiable x, Data.Identifiable.Identifiable addr, Data.Order.PreOrd y) => Data.Order.PreOrd (Data.Abstract.FiniteMap.Map x addr y)
instance (Data.Identifiable.Identifiable x, Data.Identifiable.Identifiable addr, Data.Order.Complete y) => Data.Order.Complete (Data.Abstract.FiniteMap.Map x addr y)

module Data.Abstract.Failure

-- | Failure is an Either-like type with the special ordering Failure ⊑
--   Success. Left and Right of the regular Either type, on the other hand
--   are incomparable.
data Failure e a
Fail :: e -> Failure e a
Success :: a -> Failure e a
widening :: Widening a -> Widening (Failure e a)
fromFailure :: a -> Failure e a -> a
fromEither :: Either e a -> Failure e a
toEither :: Failure e a -> Either e a
fromMaybe :: Maybe a -> Failure () a
toMaybe :: Failure e a -> Maybe a
instance Control.DeepSeq.NFData e => Control.DeepSeq.NFData1 (Data.Abstract.Failure.Failure e)
instance (Control.DeepSeq.NFData e, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Data.Abstract.Failure.Failure e a)
instance GHC.Generics.Generic1 (Data.Abstract.Failure.Failure e)
instance GHC.Generics.Generic (Data.Abstract.Failure.Failure e a)
instance GHC.Base.Functor (Data.Abstract.Failure.Failure e)
instance (GHC.Classes.Eq e, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Abstract.Failure.Failure e a)
instance (GHC.Show.Show e, GHC.Show.Show a) => GHC.Show.Show (Data.Abstract.Failure.Failure e a)
instance (Data.Hashable.Class.Hashable e, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Data.Abstract.Failure.Failure e a)
instance Data.Order.PreOrd a => Data.Order.PreOrd (Data.Abstract.Failure.Failure e a)
instance Data.Order.Complete a => Data.Order.Complete (Data.Abstract.Failure.Failure e a)
instance Data.Order.UpperBounded a => Data.Order.UpperBounded (Data.Abstract.Failure.Failure e a)
instance (Data.Order.PreOrd e, Data.Order.PreOrd a, Data.Order.Complete (Data.Abstract.FreeCompletion.FreeCompletion a)) => Data.Order.Complete (Data.Abstract.FreeCompletion.FreeCompletion (Data.Abstract.Failure.Failure e a))
instance Data.Bifunctor.Bifunctor Data.Abstract.Failure.Failure
instance Control.Monad.Error.Class.MonadError e (Data.Abstract.Failure.Failure e)
instance GHC.Base.Applicative (Data.Abstract.Failure.Failure e)
instance GHC.Base.Monad (Data.Abstract.Failure.Failure e)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Monad.ArrowFunctor (Data.Abstract.Failure.Failure e) c c
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Monad.ArrowMonad (Data.Abstract.Failure.Failure e) c

module Data.Abstract.Either

-- | Abstract <a>Either</a> type with an upper bound for <a>Left</a> and
--   <a>Right</a>.
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b
LeftRight :: a -> b -> Either a b
widening :: Widening a -> Widening b -> Widening (Either a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Abstract.Either.Either a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Data.Abstract.Either.Either a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Data.Abstract.Either.Either a b)
instance (Data.Hashable.Class.Hashable a, Data.Hashable.Class.Hashable b) => Data.Hashable.Class.Hashable (Data.Abstract.Either.Either a b)
instance (Data.Order.PreOrd a, Data.Order.PreOrd b) => Data.Order.PreOrd (Data.Abstract.Either.Either a b)
instance (Data.Order.Complete a, Data.Order.Complete b) => Data.Order.Complete (Data.Abstract.Either.Either a b)
instance Data.Bifunctor.Bifunctor Data.Abstract.Either.Either
instance GHC.Base.Functor (Data.Abstract.Either.Either a)
instance Data.Order.Complete a => GHC.Base.Applicative (Data.Abstract.Either.Either a)
instance Data.Order.Complete a => GHC.Base.Monad (Data.Abstract.Either.Either a)
instance Data.Foldable.Foldable (Data.Abstract.Either.Either a)
instance Data.Traversable.Traversable (Data.Abstract.Either.Either a)

module Data.Abstract.TreeGrammar.Terminal
class Terminal t
nonTerminals :: (Terminal t, Identifiable n) => t n -> HashSet n
productive :: (Terminal t, Identifiable n) => HashSet n -> t n -> Bool
filter :: Terminal t => (n -> Bool) -> t n -> t n
determinize :: (Terminal t, Identifiable n, Identifiable n', Applicative f) => (HashSet n -> f n') -> t n -> f (t n')
subsetOf :: (Terminal t, Identifiable n, Identifiable n', MonadPlus f) => ([(n, n')] -> f ()) -> t n -> t n' -> f ()
intersection :: (Terminal t, Identifiable n1, Identifiable n2, Identifiable n', Applicative f) => ((n1, n2) -> f n') -> t n1 -> t n2 -> f (t n')
union :: (Terminal t, Identifiable n1, Identifiable n2, Identifiable n', Applicative f) => (Either n1 n2 -> f n') -> t n1 -> t n2 -> f (t n')
traverse :: (Terminal t, Identifiable n', Applicative f) => (n -> f n') -> t n -> f (t n')
hashWithSalt :: (Terminal t, Identifiable n, Monad f) => (Int -> n -> f Int) -> Int -> t n -> f Int
map :: (Identifiable n, Identifiable n', Terminal t) => (n -> n') -> t n -> t n'
data Constr n
instance GHC.Classes.Eq n => GHC.Classes.Eq (Data.Abstract.TreeGrammar.Terminal.Constr n)
instance Data.Abstract.TreeGrammar.Terminal.Identifiable n => GHC.Exts.IsList (Data.Abstract.TreeGrammar.Terminal.Constr n)
instance Data.Abstract.TreeGrammar.Terminal.Identifiable n => GHC.Base.Semigroup (Data.Abstract.TreeGrammar.Terminal.Constr n)
instance Data.Abstract.TreeGrammar.Terminal.Identifiable n => GHC.Base.Monoid (Data.Abstract.TreeGrammar.Terminal.Constr n)
instance (GHC.Show.Show n, Data.Abstract.TreeGrammar.Terminal.Identifiable n) => GHC.Show.Show (Data.Abstract.TreeGrammar.Terminal.Constr n)
instance Data.Abstract.TreeGrammar.Terminal.Terminal Data.Abstract.TreeGrammar.Terminal.Constr

module Data.Abstract.Boolean
data Bool
True :: Bool
False :: Bool
Top :: Bool
widening :: Widening Bool
instance GHC.Generics.Generic Data.Abstract.Boolean.Bool
instance GHC.Classes.Eq Data.Abstract.Boolean.Bool
instance GHC.Show.Show Data.Abstract.Boolean.Bool
instance Data.Boolean.Logic Data.Abstract.Boolean.Bool
instance Data.Order.PreOrd Data.Abstract.Boolean.Bool
instance Data.Order.Complete Data.Abstract.Boolean.Bool
instance Data.Order.UpperBounded Data.Abstract.Boolean.Bool
instance Data.Hashable.Class.Hashable Data.Abstract.Boolean.Bool

module Data.OrdMap

-- | Datatype that describes a subset of a heterogenous order with fast
--   access to the lower and upper sets of elements.
data OrdMap n1 n2
empty :: OrdMap n1 n2
insert :: (Identifiable n1, Identifiable n2) => n1 -> n2 -> Ordering -> OrdMap n1 n2 -> OrdMap n1 n2
compare :: (Identifiable n1, Identifiable n2) => n1 -> n2 -> Ordering -> OrdMap n1 n2 -> Bool
data Ordering
LessThanEquals :: Ordering
Equivalent :: Ordering
GreaterThanEquals :: Ordering
NotLessThanEquals :: Ordering
Incomparable :: Ordering
NotGreaterThanEquals :: Ordering
StrictLessThan :: Ordering
StrictGreaterThan :: Ordering
instance GHC.Classes.Eq Data.OrdMap.Ordering
instance (Data.Identifiable.Identifiable n1, Data.Identifiable.Identifiable n2) => GHC.Base.Semigroup (Data.OrdMap.OrdMap n1 n2)
instance (Data.Identifiable.Identifiable n1, Data.Identifiable.Identifiable n2) => GHC.Base.Monoid (Data.OrdMap.OrdMap n1 n2)
instance Data.Order.PreOrd Data.OrdMap.Ordering
instance Data.Order.Complete Data.OrdMap.Ordering

module Data.Abstract.TreeGrammar
data Grammar n t
type IsGrammar n t = (Terminal t, Monoid (t n), NonTerminal n, Identifiable n)
grammar :: (IsGrammar n t, Monoid (t String)) => String -> [(String, t String)] -> [(String, [String])] -> Grammar n t
union :: forall n1 n2 n' t. (IsGrammar n1 t, IsGrammar n2 t, IsGrammar n' t) => Grammar n1 t -> Grammar n2 t -> Grammar n' t
intersection :: forall n1 n2 n' t. (IsGrammar n1 t, IsGrammar n2 t, Monoid (t n1), Monoid (t n2), IsGrammar n' t) => Grammar n1 t -> Grammar n2 t -> Grammar n' t

-- | Inlines all productions reachable via epsilon rules.
epsilonClosure :: (Identifiable n, IsGrammar n t) => Grammar n t -> Grammar n t

-- | Removes productions that are not reachable from the start symbol.
dropUnreachable :: IsGrammar n t => Grammar n t -> Grammar n t
dropUnproductive :: IsGrammar n t => Grammar n t -> Grammar n t

-- | Returns all productive nonterminals in the given grammar.
productive :: forall n t. IsGrammar n t => Grammar n t -> HashSet n
determinize :: forall n n' t. (IsGrammar n t, IsGrammar n' t) => Grammar n t -> Grammar n' t
subsetOf :: (IsGrammar n1 t, IsGrammar n2 t) => Grammar n1 t -> Grammar n2 t -> Bool
subsetOf' :: forall n1 n2 t. (IsGrammar n1 t, IsGrammar n2 t) => Grammar n1 t -> Grammar n2 t -> OrdMap n1 n2 -> (Bool, OrdMap n1 n2)
toSubterms :: (IsGrammar n t, Monoid (t Int)) => Grammar n t -> t (Grammar n t)
fromSubterms :: (IsGrammar n t, IsGrammar n' t) => t (Grammar n t) -> Grammar n' t
isEmpty :: (Eq (t n), IsGrammar n t) => Grammar n t -> Bool

-- | Optimizes the grammar by joining non-terminals that produce the same
--   language. This function has a runtime complexity <i>O(n*log(n))</i>
--   where <i>n</i> is the number of reachable non-terminals.
deduplicate :: forall n n' t. (IsGrammar n t, IsGrammar n' t) => Grammar n t -> Grammar n' t

-- | Returns the equivalence classes of non-terminals that produce the same
--   language. This function has a runtime complexity <i>O(n*log(n))</i>
--   where <i>n</i> is the number of non-terminals.
equivalenceClasses :: IsGrammar n t => Grammar n t -> HashMap n (Seq n)
instance Data.Abstract.TreeGrammar.IsGrammar n t => GHC.Classes.Eq (Data.Abstract.TreeGrammar.Grammar n t)
instance (Data.Abstract.TreeGrammar.IsGrammar n t, GHC.Base.Monoid (t GHC.Types.Int)) => Data.Hashable.Class.Hashable (Data.Abstract.TreeGrammar.Grammar n t)
instance Data.Abstract.TreeGrammar.IsGrammar n t => Data.Order.PreOrd (Data.Abstract.TreeGrammar.Grammar n t)
instance Data.Abstract.TreeGrammar.IsGrammar n t => Data.Order.Complete (Data.Abstract.TreeGrammar.Grammar n t)
instance Data.Abstract.TreeGrammar.IsGrammar n t => Data.Order.CoComplete (Data.Abstract.TreeGrammar.Grammar n t)
instance (Data.Order.UpperBounded (t GHC.Base.String), GHC.Base.Monoid (t GHC.Base.String), Data.Abstract.TreeGrammar.IsGrammar n t) => Data.Order.UpperBounded (Data.Abstract.TreeGrammar.Grammar n t)
instance (GHC.Show.Show n, GHC.Show.Show (t n)) => GHC.Show.Show (Data.Abstract.TreeGrammar.Grammar n t)
instance (Data.Abstract.TreeGrammar.Identifiable n, GHC.Base.Semigroup (t n)) => GHC.Base.Semigroup (Data.Abstract.TreeGrammar.Rhs n t)
instance (Data.Abstract.TreeGrammar.Identifiable n, GHC.Base.Monoid (t n)) => GHC.Base.Monoid (Data.Abstract.TreeGrammar.Rhs n t)
instance (GHC.Show.Show n, GHC.Show.Show (t n)) => GHC.Show.Show (Data.Abstract.TreeGrammar.Rhs n t)

module Data.Abstract.Ordering
class Ordering a
(<) :: Ordering a => a -> a -> Bool

module Data.Abstract.Equality
class Equality a
(==) :: Equality a => a -> a -> Bool
instance Data.Abstract.Equality.Equality Data.Abstract.Boolean.Bool

module Data.Abstract.Sign
data Sign
Negative :: Sign
Zero :: Sign
Positive :: Sign
Top :: Sign
widening :: Widening Sign
instance GHC.Generics.Generic Data.Abstract.Sign.Sign
instance GHC.Classes.Eq Data.Abstract.Sign.Sign
instance GHC.Show.Show Data.Abstract.Sign.Sign
instance GHC.Num.Num Data.Abstract.Sign.Sign
instance Data.Numeric.Numeric Data.Abstract.Sign.Sign (Data.Abstract.Failure.Failure GHC.Base.String)
instance Data.Abstract.Equality.Equality Data.Abstract.Sign.Sign
instance Data.Order.PreOrd Data.Abstract.Sign.Sign
instance Data.Order.Complete Data.Abstract.Sign.Sign
instance Data.Order.UpperBounded Data.Abstract.Sign.Sign
instance Data.Hashable.Class.Hashable Data.Abstract.Sign.Sign

module Data.Abstract.Interval

-- | Intervals represent ranges of numbers. Bot represents the empty
--   interval
data Interval n
Interval :: n -> n -> Interval n
constant :: n -> Interval n
withBounds1 :: Ord n => (n -> n) -> Interval n -> Interval n
withBounds2 :: Ord n => (n -> n -> n) -> Interval n -> Interval n -> Interval n
widening :: Ord n => Widening (Interval (InfiniteNumber n))
instance GHC.Generics.Generic (Data.Abstract.Interval.Interval n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Data.Abstract.Interval.Interval n)
instance GHC.Show.Show n => GHC.Show.Show (Data.Abstract.Interval.Interval n)
instance GHC.Classes.Ord x => Data.Order.PreOrd (Data.Abstract.Interval.Interval x)
instance GHC.Classes.Ord x => Data.Order.Complete (Data.Abstract.Interval.Interval x)
instance (GHC.Num.Num n, GHC.Classes.Ord n) => GHC.Num.Num (Data.Abstract.Interval.Interval n)
instance (GHC.Real.Integral n, GHC.Num.Num n, GHC.Classes.Ord n) => Data.Numeric.Numeric (Data.Abstract.Interval.Interval (Data.Abstract.InfiniteNumbers.InfiniteNumber n)) (Data.Abstract.Failure.Failure GHC.Base.String)
instance GHC.Classes.Ord n => Data.Abstract.Equality.Equality (Data.Abstract.Interval.Interval n)
instance GHC.Classes.Ord n => Data.Abstract.Ordering.Ordering (Data.Abstract.Interval.Interval n)
instance Data.Hashable.Class.Hashable n => Data.Hashable.Class.Hashable (Data.Abstract.Interval.Interval n)
instance (GHC.Classes.Ord n, GHC.Enum.Bounded n) => Data.Order.UpperBounded (Data.Abstract.Interval.Interval n)

module Control.Arrow.Abstract.Join
class (Arrow c, Profunctor c) => ArrowJoin c

-- | Join two arrow computation with the provided upper bound operator.
--
--   Laws: <tt> joinWith (⊔) f g = joined f g </tt>
joinWith :: ArrowJoin c => (y -> y -> y) -> c x y -> c x y -> c x y
joinWith' :: ArrowJoin c => (y -> y -> y) -> c x y -> c x' y -> c (x, x') y
(<⊔>) :: (ArrowJoin c, Complete y) => c x y -> c x y -> c x y

-- | Joins a list of arguments. Use it with idiom brackets: <tt> let a =
--   ...; b = ...; xs = ... (| joinList (returnA -<a>(x -</a> f -&lt; x+b)
--   |) xs </tt>
joinList :: (ArrowChoice c, ArrowJoin c, Complete y) => c (e, s) y -> c (e, (x, s)) y -> c (e, ([x], s)) y
joinList1 :: (ArrowChoice c, ArrowJoin c, Complete y) => c (e, (x, s)) y -> c (e, ([x], s)) y
instance Control.Arrow.Abstract.Join.ArrowJoin (->)

module Data.Abstract.Except

-- | Abstrat domain for exceptions. This abstract domain approximates error
--   more precisely because 'Success ⋢ Fail'. Use this type for analysis in
--   languages that can handle exceptions.
data Except e x
Success :: x -> Except e x
Fail :: e -> Except e x
SuccessOrFail :: e -> x -> Except e x
widening :: Widening e -> Widening a -> Widening (Except e a)
toEither :: Except e a -> Either e (Either a (e, a))
fromMaybe :: Maybe a -> Except () a
toMaybe :: Except e a -> Maybe a
instance Control.DeepSeq.NFData e => Control.DeepSeq.NFData1 (Data.Abstract.Except.Except e)
instance (Control.DeepSeq.NFData x, Control.DeepSeq.NFData e) => Control.DeepSeq.NFData (Data.Abstract.Except.Except e x)
instance GHC.Generics.Generic1 (Data.Abstract.Except.Except e)
instance GHC.Generics.Generic (Data.Abstract.Except.Except e x)
instance (GHC.Show.Show x, GHC.Show.Show e) => GHC.Show.Show (Data.Abstract.Except.Except e x)
instance (GHC.Classes.Eq x, GHC.Classes.Eq e) => GHC.Classes.Eq (Data.Abstract.Except.Except e x)
instance (Data.Hashable.Class.Hashable e, Data.Hashable.Class.Hashable x) => Data.Hashable.Class.Hashable (Data.Abstract.Except.Except e x)
instance (Data.Order.PreOrd e, Data.Order.PreOrd a) => Data.Order.PreOrd (Data.Abstract.Except.Except e a)
instance (Data.Order.Complete e, Data.Order.Complete a) => Data.Order.Complete (Data.Abstract.Except.Except e a)
instance (Data.Order.PreOrd e, Data.Order.PreOrd a, Data.Order.Complete (Data.Abstract.FreeCompletion.FreeCompletion e), Data.Order.Complete (Data.Abstract.FreeCompletion.FreeCompletion a)) => Data.Order.Complete (Data.Abstract.FreeCompletion.FreeCompletion (Data.Abstract.Except.Except e a))
instance (Data.Order.UpperBounded e, Data.Order.UpperBounded a) => Data.Order.UpperBounded (Data.Abstract.Except.Except e a)
instance ((TypeError ...), Data.Order.PreOrd a, Data.Order.PreOrd e) => Data.Order.LowerBounded (Data.Abstract.Except.Except e a)
instance (Data.Order.PreOrd a, Data.Order.PreOrd e, Data.Order.UpperBounded (Data.Abstract.FreeCompletion.FreeCompletion e), Data.Order.UpperBounded (Data.Abstract.FreeCompletion.FreeCompletion a)) => Data.Order.UpperBounded (Data.Abstract.FreeCompletion.FreeCompletion (Data.Abstract.Except.Except e a))
instance Data.Bifunctor.Bifunctor Data.Abstract.Except.Except
instance GHC.Base.Functor (Data.Abstract.Except.Except e)
instance Data.Order.Complete e => GHC.Base.Applicative (Data.Abstract.Except.Except e)
instance Data.Order.Complete e => GHC.Base.Monad (Data.Abstract.Except.Except e)
instance (Control.Arrow.Abstract.Join.ArrowJoin c, Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Monad.ArrowFunctor (Data.Abstract.Except.Except e) c c
instance (Data.Order.Complete e, Control.Arrow.Abstract.Join.ArrowJoin c, Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Monad.ArrowMonad (Data.Abstract.Except.Except e) c
instance Data.Foldable.Foldable (Data.Abstract.Except.Except e)
instance Data.Traversable.Traversable (Data.Abstract.Except.Except e)

module Data.GaloisConnection

-- | A galois connection consisting of an abstraction function alpha and a
--   concretization function gamma between two pre-ordered sets has to
--   satisfy forall x,y. alpha x ⊑ y iff x ⊑ gamma y
class (PreOrd x, PreOrd y) => Galois x y
alpha :: Galois x y => x -> y
gamma :: Galois x y => y -> x
alphaSing :: Galois (Pow x) x' => x -> x'
lifted :: Complete y => (x -> y) -> Pow x -> y
instance (Data.GaloisConnection.Galois x x', Data.GaloisConnection.Galois y y') => Data.GaloisConnection.Galois (x, y) (x', y')
instance (Data.Identifiable.Identifiable (x, y), Data.GaloisConnection.Galois (Data.Concrete.Powerset.Pow x) x', Data.GaloisConnection.Galois (Data.Concrete.Powerset.Pow y) y') => Data.GaloisConnection.Galois (Data.Concrete.Powerset.Pow (x, y)) (x', y')
instance Data.GaloisConnection.Galois (Data.Concrete.Powerset.Pow GHC.Types.Bool) Data.Abstract.Boolean.Bool
instance (Data.Hashable.Class.Hashable a, GHC.Classes.Eq a, GHC.Classes.Ord a, GHC.Enum.Enum a) => Data.GaloisConnection.Galois (Data.Concrete.Powerset.Pow a) (Data.Abstract.Interval.Interval a)
instance (Data.GaloisConnection.Galois (m y) (n y'), Data.GaloisConnection.Galois x x') => Data.GaloisConnection.Galois (Control.Arrow.Kleisli m x y) (Control.Arrow.Kleisli n x' y')
instance (Data.Order.Complete a', GHC.Classes.Eq a, Data.Hashable.Class.Hashable a, Data.GaloisConnection.Galois (Data.Concrete.Powerset.Pow a) a', GHC.Classes.Eq b, Data.Hashable.Class.Hashable b, Data.Order.Complete b', Data.GaloisConnection.Galois (Data.Concrete.Powerset.Pow b) b') => Data.GaloisConnection.Galois (Data.Concrete.Powerset.Pow (Data.Concrete.Error.Error a b)) (Data.Abstract.Except.Except a' b')
instance (GHC.Classes.Eq e, Data.Hashable.Class.Hashable e, GHC.Classes.Eq b, Data.Hashable.Class.Hashable b, Data.Order.Complete b', Data.GaloisConnection.Galois (Data.Concrete.Powerset.Pow b) b') => Data.GaloisConnection.Galois (Data.Concrete.Powerset.Pow (Data.Concrete.Error.Error e b)) (Data.Abstract.Failure.Failure e b')
instance (Data.Hashable.Class.Hashable a, GHC.Classes.Eq a, Data.Order.Complete a', Data.GaloisConnection.Galois (Data.Concrete.Powerset.Pow a) a') => Data.GaloisConnection.Galois (Data.Concrete.Powerset.Pow (GHC.Maybe.Maybe a)) (GHC.Maybe.Maybe a')
instance Data.GaloisConnection.Galois (Data.Concrete.Powerset.Pow a) a' => Data.GaloisConnection.Galois (Data.Concrete.Powerset.Pow a) (Data.Abstract.Powerset.Pow a')
instance Data.GaloisConnection.Galois (Data.Concrete.Powerset.Pow ()) ()

module Data.Abstract.Error

-- | Error is an Either-like type with the ordering Success ⊑ Failure.
data Error e a
Fail :: e -> Error e a
Success :: a -> Error e a
widening :: Widening e -> Widening a -> Widening (Error e a)
fromError :: a -> Error e a -> a
fromEither :: Either e a -> Error e a
toEither :: Error e a -> Either e a
fromMaybe :: Maybe a -> Error () a
toMaybe :: Error e a -> Maybe a
instance Control.DeepSeq.NFData e => Control.DeepSeq.NFData1 (Data.Abstract.Error.Error e)
instance (Control.DeepSeq.NFData e, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Data.Abstract.Error.Error e a)
instance GHC.Generics.Generic1 (Data.Abstract.Error.Error e)
instance GHC.Generics.Generic (Data.Abstract.Error.Error e a)
instance GHC.Base.Functor (Data.Abstract.Error.Error e)
instance (GHC.Classes.Eq e, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Abstract.Error.Error e a)
instance (GHC.Show.Show e, GHC.Show.Show a) => GHC.Show.Show (Data.Abstract.Error.Error e a)
instance (Data.Hashable.Class.Hashable e, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Data.Abstract.Error.Error e a)
instance Data.Bifunctor.Bifunctor Data.Abstract.Error.Error
instance Control.Monad.Error.Class.MonadError e (Data.Abstract.Error.Error e)
instance GHC.Base.Applicative (Data.Abstract.Error.Error e)
instance GHC.Base.Monad (Data.Abstract.Error.Error e)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Monad.ArrowFunctor (Data.Abstract.Error.Error e) c c
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Monad.ArrowMonad (Data.Abstract.Error.Error e) c
instance (Data.Order.PreOrd e, Data.Order.PreOrd a) => Data.Order.PreOrd (Data.Abstract.Error.Error e a)
instance (Data.Order.Complete e, Data.Order.Complete a) => Data.Order.Complete (Data.Abstract.Error.Error e a)
instance (Data.Order.PreOrd a, Data.Order.UpperBounded e) => Data.Order.UpperBounded (Data.Abstract.Error.Error e a)
instance (Data.Order.PreOrd e, Data.Order.PreOrd a, Data.Order.Complete (Data.Abstract.FreeCompletion.FreeCompletion e), Data.Order.Complete (Data.Abstract.FreeCompletion.FreeCompletion a)) => Data.Order.Complete (Data.Abstract.FreeCompletion.FreeCompletion (Data.Abstract.Error.Error e a))
instance (Data.Identifiable.Identifiable a, Data.Identifiable.Identifiable e, Data.Order.Complete e', Data.Order.Complete a', Data.GaloisConnection.Galois (Data.Concrete.Powerset.Pow e) e', Data.GaloisConnection.Galois (Data.Concrete.Powerset.Pow a) a') => Data.GaloisConnection.Galois (Data.Concrete.Powerset.Pow (Data.Concrete.Error.Error e a)) (Data.Abstract.Error.Error e' a')

module Data.Abstract.DiscretePowerset
data Pow x
Pow :: HashSet x -> Pow x
Top :: Pow x
empty :: Pow a
singleton :: Identifiable x => x -> Pow x
union :: Identifiable x => Pow x -> Pow x -> Pow x
unions :: Identifiable x => Pow (Pow x) -> Pow x
insert :: Identifiable x => x -> Pow x -> Pow x
delete :: Identifiable x => x -> Pow x -> Pow x
map :: Identifiable y => (x -> y) -> Pow x -> Pow y
fromMaybe :: Identifiable x => Maybe x -> Pow x
widening :: Identifiable x => Widening (Pow x)
instance GHC.Generics.Generic (Data.Abstract.DiscretePowerset.Pow x)
instance GHC.Classes.Eq x => GHC.Classes.Eq (Data.Abstract.DiscretePowerset.Pow x)
instance Control.DeepSeq.NFData x => Control.DeepSeq.NFData (Data.Abstract.DiscretePowerset.Pow x)
instance GHC.Show.Show a => GHC.Show.Show (Data.Abstract.DiscretePowerset.Pow a)
instance Data.Identifiable.Identifiable x => Data.Order.PreOrd (Data.Abstract.DiscretePowerset.Pow x)
instance Data.Identifiable.Identifiable x => Data.Order.Complete (Data.Abstract.DiscretePowerset.Pow x)
instance Data.Identifiable.Identifiable x => Data.Order.Complete (Data.Abstract.FreeCompletion.FreeCompletion (Data.Abstract.DiscretePowerset.Pow x))
instance Data.Hashable.Class.Hashable x => Data.Hashable.Class.Hashable (Data.Abstract.DiscretePowerset.Pow x)
instance Data.Identifiable.Identifiable x => Data.Order.UpperBounded (Data.Abstract.DiscretePowerset.Pow x)
instance Data.Identifiable.Identifiable x => Data.Order.LowerBounded (Data.Abstract.DiscretePowerset.Pow x)
instance Data.Identifiable.Identifiable x => GHC.Exts.IsList (Data.Abstract.DiscretePowerset.Pow x)
instance (Data.String.IsString x, Data.Identifiable.Identifiable x) => Data.String.IsString (Data.Abstract.DiscretePowerset.Pow x)
instance Data.Identifiable.Identifiable a => Data.GaloisConnection.Galois (Data.Concrete.Powerset.Pow a) (Data.Abstract.DiscretePowerset.Pow a)

module Data.Abstract.Closure
data Closure expr env
closure :: Identifiable expr => expr -> env -> Closure expr env
apply :: (ArrowJoin c, ArrowChoice c, Profunctor c, Complete y) => c (e, ((expr, env), s)) y -> c (e, (Closure expr env, s)) y
widening :: Identifiable expr => Widening env -> Widening (Closure expr env)
instance (Control.DeepSeq.NFData expr, Control.DeepSeq.NFData env) => Control.DeepSeq.NFData (Data.Abstract.Closure.Closure expr env)
instance (Data.Hashable.Class.Hashable expr, Data.Hashable.Class.Hashable env) => Data.Hashable.Class.Hashable (Data.Abstract.Closure.Closure expr env)
instance (GHC.Classes.Eq expr, GHC.Classes.Eq env) => GHC.Classes.Eq (Data.Abstract.Closure.Closure expr env)
instance (Data.Identifiable.Identifiable expr, Data.Order.PreOrd env) => Data.Order.PreOrd (Data.Abstract.Closure.Closure expr env)
instance (Data.Identifiable.Identifiable expr, Data.Order.Complete env) => Data.Order.Complete (Data.Abstract.Closure.Closure expr env)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Abstract.Closure.Closure a b)

module Control.Arrow.Transformer.Writer
newtype WriterT w c x y
WriterT :: c x (w, y) -> WriterT w c x y
[runWriterT] :: WriterT w c x y -> c x (w, y)
instance Data.Order.PreOrd (c x (w, y)) => Data.Order.PreOrd (Control.Arrow.Transformer.Writer.WriterT w c x y)
instance Data.Order.LowerBounded (c x (w, y)) => Data.Order.LowerBounded (Control.Arrow.Transformer.Writer.WriterT w c x y)
instance Data.Order.Complete (c x (w, y)) => Data.Order.Complete (Control.Arrow.Transformer.Writer.WriterT w c x y)
instance Data.Order.CoComplete (c x (w, y)) => Data.Order.CoComplete (Control.Arrow.Transformer.Writer.WriterT w c x y)
instance Data.Order.UpperBounded (c x (w, y)) => Data.Order.UpperBounded (Control.Arrow.Transformer.Writer.WriterT w c x y)
instance (Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.Arrow c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Writer.WriterT w c)
instance Control.Arrow.Trans.ArrowTrans (Control.Arrow.Transformer.Writer.WriterT w)
instance GHC.Base.Monoid w => Control.Arrow.Trans.ArrowLift (Control.Arrow.Transformer.Writer.WriterT w)
instance (GHC.Base.Monoid w, Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Writer.WriterT w c)
instance (GHC.Base.Monoid w, Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Writer.WriterT w c)
instance (GHC.Base.Monoid w, Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Writer.WriterT w c)
instance (GHC.Base.Monoid w, Control.Arrow.ArrowApply c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Writer.WriterT w c)
instance (GHC.Base.Monoid w, Control.Arrow.State.ArrowState s c) => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Writer.WriterT w c)
instance (GHC.Base.Monoid w, Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Writer.ArrowWriter w (Control.Arrow.Transformer.Writer.WriterT w c)
instance (GHC.Base.Monoid w, Control.Arrow.Fail.ArrowFail e c) => Control.Arrow.Fail.ArrowFail e (Control.Arrow.Transformer.Writer.WriterT w c)
instance (GHC.Base.Monoid w, Control.Arrow.Except.ArrowExcept e c) => Control.Arrow.Except.ArrowExcept e (Control.Arrow.Transformer.Writer.WriterT w c)
instance (GHC.Base.Monoid w, Control.Arrow.Reader.ArrowReader r c) => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.Writer.WriterT w c)
instance (GHC.Base.Monoid w, Control.Arrow.Environment.ArrowEnv x y env c) => Control.Arrow.Environment.ArrowEnv x y env (Control.Arrow.Transformer.Writer.WriterT w c)
instance (GHC.Base.Monoid w, Control.Arrow.Store.ArrowStore var val c) => Control.Arrow.Store.ArrowStore var val (Control.Arrow.Transformer.Writer.WriterT w c)
instance (GHC.Base.Monoid w, Control.Arrow.Fix.ArrowFix x (w, y) c) => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Writer.WriterT w c)
instance (GHC.Base.Monoid w, Data.Order.Complete w, Control.Arrow.Abstract.Join.ArrowJoin c) => Control.Arrow.Abstract.Join.ArrowJoin (Control.Arrow.Transformer.Writer.WriterT w c)
instance (GHC.Base.Monoid w, Control.Arrow.Alloc.ArrowAlloc x y c) => Control.Arrow.Alloc.ArrowAlloc x y (Control.Arrow.Transformer.Writer.WriterT w c)
instance (GHC.Base.Monoid w, Control.Arrow.Conditional.ArrowCond v c) => Control.Arrow.Conditional.ArrowCond v (Control.Arrow.Transformer.Writer.WriterT w c)
instance (GHC.Base.Monoid w, Control.Arrow.Random.ArrowRand v c) => Control.Arrow.Random.ArrowRand v (Control.Arrow.Transformer.Writer.WriterT w c)
instance (GHC.Base.Monoid w, Control.Arrow.Const.ArrowConst x c) => Control.Arrow.Const.ArrowConst x (Control.Arrow.Transformer.Writer.WriterT w c)

module Control.Arrow.Transformer.Concrete.Trace
data Entry a b
Call :: a -> Entry a b
Return :: b -> Entry a b
type Log a b = Seq (Entry a b)
newtype TraceT a b c x y
TraceT :: WriterT (Log a b) c x y -> TraceT a b c x y
runTraceT :: TraceT a b c x y -> c x (Log a b, y)
instance Control.Arrow.Trans.ArrowTrans (Control.Arrow.Transformer.Concrete.Trace.TraceT a b)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Concrete.Trace.TraceT a b c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Concrete.Trace.TraceT a b c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Concrete.Trace.TraceT a b c)
instance (Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.Arrow c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Concrete.Trace.TraceT a b c)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Control.Arrow.Transformer.Concrete.Trace.Entry a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Control.Arrow.Transformer.Concrete.Trace.Entry a b)
instance (Control.Arrow.ArrowApply c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Concrete.Trace.TraceT a b c)
instance Control.Arrow.Fix.ArrowFix (Control.Arrow.Trans.Dom (Control.Arrow.Transformer.Concrete.Trace.TraceT x y) x y) (Control.Arrow.Trans.Cod (Control.Arrow.Transformer.Concrete.Trace.TraceT x y) x y) c => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Concrete.Trace.TraceT x y c)

module Control.Arrow.Transformer.Static
newtype StaticT f c x y
StaticT :: f (c x y) -> StaticT f c x y
[runStaticT] :: StaticT f c x y -> f (c x y)
instance (GHC.Base.Applicative f, Data.Profunctor.Unsafe.Profunctor c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Static.StaticT f c)
instance GHC.Base.Applicative f => Control.Arrow.Trans.ArrowLift (Control.Arrow.Transformer.Static.StaticT f)
instance (GHC.Base.Applicative f, Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Static.StaticT f c)
instance (GHC.Base.Applicative f, Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Static.StaticT f c)
instance (GHC.Base.Applicative f, Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Static.StaticT f c)
instance (GHC.Base.Applicative f, Control.Arrow.State.ArrowState s c) => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Static.StaticT f c)
instance (GHC.Base.Applicative f, Control.Arrow.Reader.ArrowReader r c) => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.Static.StaticT f c)
instance (GHC.Base.Applicative f, Control.Arrow.Writer.ArrowWriter w c) => Control.Arrow.Writer.ArrowWriter w (Control.Arrow.Transformer.Static.StaticT f c)
instance (GHC.Base.Applicative f, Control.Arrow.Fail.ArrowFail e c) => Control.Arrow.Fail.ArrowFail e (Control.Arrow.Transformer.Static.StaticT f c)
instance (GHC.Base.Applicative f, Control.Arrow.Except.ArrowExcept e c) => Control.Arrow.Except.ArrowExcept e (Control.Arrow.Transformer.Static.StaticT f c)
instance (GHC.Base.Applicative f, Control.Arrow.Environment.ArrowEnv var val env c) => Control.Arrow.Environment.ArrowEnv var val env (Control.Arrow.Transformer.Static.StaticT f c)
instance (GHC.Base.Applicative f, Control.Arrow.Store.ArrowStore var val c) => Control.Arrow.Store.ArrowStore var val (Control.Arrow.Transformer.Static.StaticT f c)
instance (GHC.Base.Applicative f, Control.Arrow.Abstract.Join.ArrowJoin c) => Control.Arrow.Abstract.Join.ArrowJoin (Control.Arrow.Transformer.Static.StaticT f c)
instance (GHC.Base.Applicative f, Control.Arrow.Deduplicate.ArrowDeduplicate x y c) => Control.Arrow.Deduplicate.ArrowDeduplicate x y (Control.Arrow.Transformer.Static.StaticT f c)

module Control.Arrow.Transformer.State
newtype StateT s c x y
StateT :: c (s, x) (s, y) -> StateT s c x y
[runStateT] :: StateT s c x y -> c (s, x) (s, y)
evalStateT :: (Arrow c, Profunctor c) => StateT s c x y -> c (s, x) y
execStateT :: (Arrow c, Profunctor c) => StateT s c x y -> c (s, x) s
instance (Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.Arrow c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.State.StateT s c)
instance Control.Arrow.Trans.ArrowTrans (Control.Arrow.Transformer.State.StateT s)
instance Control.Arrow.Trans.ArrowLift (Control.Arrow.Transformer.State.StateT s)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.State.StateT s c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.State.StateT s c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.State.StateT s c)
instance (Control.Arrow.ArrowApply c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.State.StateT s c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.State.StateT s c)
instance (Control.Arrow.Fail.ArrowFail e c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Fail.ArrowFail e (Control.Arrow.Transformer.State.StateT s c)
instance Control.Arrow.Reader.ArrowReader r c => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.State.StateT s c)
instance Control.Arrow.Writer.ArrowWriter w c => Control.Arrow.Writer.ArrowWriter w (Control.Arrow.Transformer.State.StateT s c)
instance Control.Arrow.Environment.ArrowEnv var val env c => Control.Arrow.Environment.ArrowEnv var val env (Control.Arrow.Transformer.State.StateT s c)
instance Control.Arrow.Store.ArrowStore var val c => Control.Arrow.Store.ArrowStore var val (Control.Arrow.Transformer.State.StateT s c)
instance Control.Arrow.Fix.ArrowFix (s, x) (s, y) c => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.State.StateT s c)
instance Control.Arrow.Except.ArrowExcept e c => Control.Arrow.Except.ArrowExcept e (Control.Arrow.Transformer.State.StateT s c)
instance (GHC.Classes.Eq s, Data.Hashable.Class.Hashable s, Control.Arrow.Deduplicate.ArrowDeduplicate (Control.Arrow.Trans.Dom (Control.Arrow.Transformer.State.StateT s) x y) (Control.Arrow.Trans.Cod (Control.Arrow.Transformer.State.StateT s) x y) c) => Control.Arrow.Deduplicate.ArrowDeduplicate x y (Control.Arrow.Transformer.State.StateT s c)
instance (Control.Arrow.Abstract.Join.ArrowJoin c, Data.Order.Complete s) => Control.Arrow.Abstract.Join.ArrowJoin (Control.Arrow.Transformer.State.StateT s c)
instance Control.Arrow.Const.ArrowConst x c => Control.Arrow.Const.ArrowConst x (Control.Arrow.Transformer.State.StateT s c)
instance Control.Arrow.Alloc.ArrowAlloc x y c => Control.Arrow.Alloc.ArrowAlloc x y (Control.Arrow.Transformer.State.StateT s c)
instance Control.Arrow.Random.ArrowRand v c => Control.Arrow.Random.ArrowRand v (Control.Arrow.Transformer.State.StateT s c)

module Control.Arrow.Transformer.Concrete.Store

-- | Arrow transformer that adds a store to a computation.
newtype StoreT var val c x y
StoreT :: StateT (HashMap var val) c x y -> StoreT var val c x y

-- | Execute a computation and only return the result value and store.
runStoreT :: StoreT var val c x y -> c (HashMap var val, x) (HashMap var val, y)

-- | Execute a computation and only return the result value.
evalStoreT :: Arrow c => StoreT var val c x y -> c (HashMap var val, x) y

-- | Execute a computation and only return the result store.
execStoreT :: Arrow c => StoreT var val c x y -> c (HashMap var val, x) (HashMap var val)
instance Control.Arrow.Except.ArrowExcept e c => Control.Arrow.Except.ArrowExcept e (Control.Arrow.Transformer.Concrete.Store.StoreT var val c)
instance Control.Arrow.Fail.ArrowFail e c => Control.Arrow.Fail.ArrowFail e (Control.Arrow.Transformer.Concrete.Store.StoreT var val c)
instance Control.Arrow.Reader.ArrowReader r c => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.Concrete.Store.StoreT var val c)
instance Control.Arrow.Const.ArrowConst r c => Control.Arrow.Const.ArrowConst r (Control.Arrow.Transformer.Concrete.Store.StoreT var val c)
instance Control.Arrow.Trans.ArrowLift (Control.Arrow.Transformer.Concrete.Store.StoreT var val)
instance Control.Arrow.Trans.ArrowTrans (Control.Arrow.Transformer.Concrete.Store.StoreT var val)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Concrete.Store.StoreT var val c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Concrete.Store.StoreT var val c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Concrete.Store.StoreT var val c)
instance (Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.Arrow c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Concrete.Store.StoreT var val c)
instance Control.Arrow.Fix.ArrowFix (Control.Arrow.Trans.Dom (Control.Arrow.Transformer.Concrete.Store.StoreT var val) x y) (Control.Arrow.Trans.Cod (Control.Arrow.Transformer.Concrete.Store.StoreT var val) x y) c => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Concrete.Store.StoreT var val c)
instance (Data.Identifiable.Identifiable var, Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Store.ArrowStore var val (Control.Arrow.Transformer.Concrete.Store.StoreT var val c)
instance Control.Arrow.State.ArrowState s c => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Concrete.Store.StoreT var val c)
instance (Control.Arrow.ArrowApply c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Concrete.Store.StoreT var val c)

module Control.Arrow.Transformer.Concrete.Random
newtype RandomT c x y
RandomT :: StateT StdGen c x y -> RandomT c x y
runRandomT :: RandomT c x y -> c (StdGen, x) (StdGen, y)
instance Control.Arrow.Store.ArrowStore var val c => Control.Arrow.Store.ArrowStore var val (Control.Arrow.Transformer.Concrete.Random.RandomT c)
instance Control.Arrow.Environment.ArrowEnv var val env c => Control.Arrow.Environment.ArrowEnv var val env (Control.Arrow.Transformer.Concrete.Random.RandomT c)
instance Control.Arrow.Except.ArrowExcept e c => Control.Arrow.Except.ArrowExcept e (Control.Arrow.Transformer.Concrete.Random.RandomT c)
instance Control.Arrow.Fail.ArrowFail e c => Control.Arrow.Fail.ArrowFail e (Control.Arrow.Transformer.Concrete.Random.RandomT c)
instance Control.Arrow.Reader.ArrowReader r c => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.Concrete.Random.RandomT c)
instance Control.Arrow.Trans.ArrowLift Control.Arrow.Transformer.Concrete.Random.RandomT
instance Control.Arrow.Trans.ArrowTrans Control.Arrow.Transformer.Concrete.Random.RandomT
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Concrete.Random.RandomT c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Concrete.Random.RandomT c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Concrete.Random.RandomT c)
instance (Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.Arrow c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Concrete.Random.RandomT c)
instance (Control.Arrow.Arrow c, Control.Arrow.Fix.ArrowFix (Control.Arrow.Trans.Dom Control.Arrow.Transformer.Concrete.Random.RandomT x y) (Control.Arrow.Trans.Cod Control.Arrow.Transformer.Concrete.Random.RandomT x y) c) => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Concrete.Random.RandomT c)
instance Control.Arrow.Alloc.ArrowAlloc x y c => Control.Arrow.Alloc.ArrowAlloc x y (Control.Arrow.Transformer.Concrete.Random.RandomT c)
instance (System.Random.Random v, Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Random.ArrowRand v (Control.Arrow.Transformer.Concrete.Random.RandomT c)
instance Control.Arrow.State.ArrowState s c => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Concrete.Random.RandomT c)

module Control.Arrow.Transformer.Reader
newtype ReaderT r c x y
ReaderT :: c (r, x) y -> ReaderT r c x y
[runReaderT] :: ReaderT r c x y -> c (r, x) y
instance (Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.Arrow c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Reader.ReaderT r c)
instance Control.Arrow.Trans.ArrowTrans (Control.Arrow.Transformer.Reader.ReaderT r)
instance Control.Arrow.Trans.ArrowLift (Control.Arrow.Transformer.Reader.ReaderT r)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Reader.ReaderT r c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Reader.ReaderT r c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Reader.ReaderT r c)
instance (Control.Arrow.ArrowApply c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Reader.ReaderT r c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.Reader.ReaderT r c)
instance Control.Arrow.State.ArrowState s c => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Reader.ReaderT r c)
instance Control.Arrow.Writer.ArrowWriter w c => Control.Arrow.Writer.ArrowWriter w (Control.Arrow.Transformer.Reader.ReaderT r c)
instance Control.Arrow.Fail.ArrowFail e c => Control.Arrow.Fail.ArrowFail e (Control.Arrow.Transformer.Reader.ReaderT r c)
instance Control.Arrow.Environment.ArrowEnv var val env c => Control.Arrow.Environment.ArrowEnv var val env (Control.Arrow.Transformer.Reader.ReaderT r c)
instance Control.Arrow.Store.ArrowStore var val c => Control.Arrow.Store.ArrowStore var val (Control.Arrow.Transformer.Reader.ReaderT r c)
instance Control.Arrow.Fix.ArrowFix (Control.Arrow.Trans.Dom (Control.Arrow.Transformer.Reader.ReaderT r) x y) (Control.Arrow.Trans.Cod (Control.Arrow.Transformer.Reader.ReaderT r) x y) c => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Reader.ReaderT r c)
instance Control.Arrow.Except.ArrowExcept e c => Control.Arrow.Except.ArrowExcept e (Control.Arrow.Transformer.Reader.ReaderT r c)
instance Control.Arrow.Deduplicate.ArrowDeduplicate (r, x) y c => Control.Arrow.Deduplicate.ArrowDeduplicate x y (Control.Arrow.Transformer.Reader.ReaderT r c)
instance Control.Arrow.Abstract.Join.ArrowJoin c => Control.Arrow.Abstract.Join.ArrowJoin (Control.Arrow.Transformer.Reader.ReaderT r c)
instance Control.Arrow.Const.ArrowConst x c => Control.Arrow.Const.ArrowConst x (Control.Arrow.Transformer.Reader.ReaderT r c)

module Control.Arrow.Transformer.Concrete.Environment

-- | Arrow transformer that adds an environment to a computation.
newtype EnvT var val c x y
EnvT :: ReaderT (HashMap var val) c x y -> EnvT var val c x y
runEnvT :: Arrow c => EnvT var val c x y -> c (HashMap var val, x) y
runEnvT' :: (Arrow c, Identifiable var) => EnvT var val c x y -> c ([(var, val)], x) y
instance Control.Arrow.Store.ArrowStore var' val' c => Control.Arrow.Store.ArrowStore var' val' (Control.Arrow.Transformer.Concrete.Environment.EnvT var val c)
instance Control.Arrow.Const.ArrowConst r c => Control.Arrow.Const.ArrowConst r (Control.Arrow.Transformer.Concrete.Environment.EnvT var val c)
instance Control.Arrow.State.ArrowState s c => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Concrete.Environment.EnvT var val c)
instance Control.Arrow.Except.ArrowExcept e c => Control.Arrow.Except.ArrowExcept e (Control.Arrow.Transformer.Concrete.Environment.EnvT var val c)
instance Control.Arrow.Fail.ArrowFail e c => Control.Arrow.Fail.ArrowFail e (Control.Arrow.Transformer.Concrete.Environment.EnvT var val c)
instance Control.Arrow.Trans.ArrowTrans (Control.Arrow.Transformer.Concrete.Environment.EnvT var val)
instance Control.Arrow.Trans.ArrowLift (Control.Arrow.Transformer.Concrete.Environment.EnvT var val)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Concrete.Environment.EnvT var val c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Concrete.Environment.EnvT var val c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Concrete.Environment.EnvT var val c)
instance (Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.Arrow c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Concrete.Environment.EnvT var val c)
instance Control.Arrow.Fix.ArrowFix (Data.HashMap.Base.HashMap var val, x) y c => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Concrete.Environment.EnvT var val c)
instance (Data.Identifiable.Identifiable var, Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Environment.ArrowEnv var val (Data.HashMap.Base.HashMap var val) (Control.Arrow.Transformer.Concrete.Environment.EnvT var val c)
instance (Control.Arrow.ArrowApply c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Concrete.Environment.EnvT var val c)
instance Control.Arrow.Reader.ArrowReader r c => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.Concrete.Environment.EnvT var val c)

module Control.Arrow.Transformer.Const

-- | Passes along constant data.
newtype ConstT r c x y
ConstT :: StaticT ((->) r) c x y -> ConstT r c x y
runConstT :: r -> ConstT r c x y -> c x y
instance Control.Arrow.Except.ArrowExcept e c => Control.Arrow.Except.ArrowExcept e (Control.Arrow.Transformer.Const.ConstT r c)
instance Control.Arrow.Fail.ArrowFail e c => Control.Arrow.Fail.ArrowFail e (Control.Arrow.Transformer.Const.ConstT r c)
instance Control.Arrow.Store.ArrowStore var val c => Control.Arrow.Store.ArrowStore var val (Control.Arrow.Transformer.Const.ConstT r c)
instance Control.Arrow.Environment.ArrowEnv var val env c => Control.Arrow.Environment.ArrowEnv var val env (Control.Arrow.Transformer.Const.ConstT r c)
instance Control.Arrow.Writer.ArrowWriter w c => Control.Arrow.Writer.ArrowWriter w (Control.Arrow.Transformer.Const.ConstT r c)
instance Control.Arrow.Reader.ArrowReader r' c => Control.Arrow.Reader.ArrowReader r' (Control.Arrow.Transformer.Const.ConstT r c)
instance Control.Arrow.State.ArrowState s c => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Const.ConstT r c)
instance Control.Arrow.Trans.ArrowLift (Control.Arrow.Transformer.Const.ConstT r)
instance Control.Arrow.Abstract.Join.ArrowJoin c => Control.Arrow.Abstract.Join.ArrowJoin (Control.Arrow.Transformer.Const.ConstT r c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Const.ConstT r c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Const.ConstT r c)
instance Data.Profunctor.Unsafe.Profunctor c => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Const.ConstT r c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Const.ConstT r c)
instance Control.Arrow.Deduplicate.ArrowDeduplicate x y c => Control.Arrow.Deduplicate.ArrowDeduplicate x y (Control.Arrow.Transformer.Const.ConstT r c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Const.ArrowConst r (Control.Arrow.Transformer.Const.ConstT r c)
instance Control.Arrow.Fix.ArrowFix x y c => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Const.ConstT r c)
instance (Control.Arrow.ArrowApply c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Const.ConstT r c)

module Control.Arrow.Transformer.Abstract.Terminating

-- | Arrow that propagates non-terminating computations.
data TerminatingT c x y
runTerminatingT :: TerminatingT c x y -> c x (Terminating y)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Const.ArrowConst r c) => Control.Arrow.Const.ArrowConst r (Control.Arrow.Transformer.Abstract.Terminating.TerminatingT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Reader.ArrowReader r c) => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.Abstract.Terminating.TerminatingT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.State.ArrowState s c) => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Abstract.Terminating.TerminatingT c)
instance Control.Arrow.Trans.ArrowLift Control.Arrow.Transformer.Abstract.Terminating.TerminatingT
instance Control.Arrow.Trans.ArrowTrans Control.Arrow.Transformer.Abstract.Terminating.TerminatingT
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Abstract.Terminating.TerminatingT c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Abstract.Terminating.TerminatingT c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Abstract.Terminating.TerminatingT c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Abstract.Terminating.TerminatingT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Fix.ArrowFix (Control.Arrow.Trans.Dom Control.Arrow.Transformer.Abstract.Terminating.TerminatingT x y) (Control.Arrow.Trans.Cod Control.Arrow.Transformer.Abstract.Terminating.TerminatingT x y) c) => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Abstract.Terminating.TerminatingT c)
instance (Data.Identifiable.Identifiable (Control.Arrow.Trans.Cod Control.Arrow.Transformer.Abstract.Terminating.TerminatingT x y), Control.Arrow.ArrowChoice c, Control.Arrow.Deduplicate.ArrowDeduplicate (Control.Arrow.Trans.Dom Control.Arrow.Transformer.Abstract.Terminating.TerminatingT x y) (Control.Arrow.Trans.Cod Control.Arrow.Transformer.Abstract.Terminating.TerminatingT x y) c) => Control.Arrow.Deduplicate.ArrowDeduplicate x y (Control.Arrow.Transformer.Abstract.Terminating.TerminatingT c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.ArrowApply c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Abstract.Terminating.TerminatingT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Abstract.Join.ArrowJoin c) => Control.Arrow.Abstract.Join.ArrowJoin (Control.Arrow.Transformer.Abstract.Terminating.TerminatingT c)

module Control.Arrow.Transformer.Abstract.Store
newtype StoreT var val c x y
StoreT :: StateT (Map var val) c x y -> StoreT var val c x y
runStoreT :: StoreT var val c x y -> c (Map var val, x) (Map var val, y)
evalStoreT :: Arrow c => StoreT var val c x y -> c (Map var val, x) y
execStoreT :: Arrow c => StoreT var val c x y -> c (Map var val, x) (Map var val)
instance Control.Arrow.Const.ArrowConst r c => Control.Arrow.Const.ArrowConst r (Control.Arrow.Transformer.Abstract.Store.StoreT var val c)
instance Control.Arrow.Environment.ArrowEnv var val env c => Control.Arrow.Environment.ArrowEnv var val env (Control.Arrow.Transformer.Abstract.Store.StoreT var val c)
instance Control.Arrow.Except.ArrowExcept e c => Control.Arrow.Except.ArrowExcept e (Control.Arrow.Transformer.Abstract.Store.StoreT var val c)
instance Control.Arrow.Fail.ArrowFail e c => Control.Arrow.Fail.ArrowFail e (Control.Arrow.Transformer.Abstract.Store.StoreT var val c)
instance Control.Arrow.Reader.ArrowReader r c => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.Abstract.Store.StoreT var val c)
instance Control.Arrow.Trans.ArrowLift (Control.Arrow.Transformer.Abstract.Store.StoreT var val)
instance Control.Arrow.Trans.ArrowTrans (Control.Arrow.Transformer.Abstract.Store.StoreT var val)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Abstract.Store.StoreT var val c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Abstract.Store.StoreT var val c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Abstract.Store.StoreT var val c)
instance (Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.Arrow c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Abstract.Store.StoreT var val c)
instance (GHC.Classes.Eq var, Data.Hashable.Class.Hashable var, Data.Order.Complete val, Control.Arrow.Abstract.Join.ArrowJoin c) => Control.Arrow.Abstract.Join.ArrowJoin (Control.Arrow.Transformer.Abstract.Store.StoreT var val c)
instance Control.Arrow.Fix.ArrowFix (Control.Arrow.Trans.Dom (Control.Arrow.Transformer.Abstract.Store.StoreT var val) x y) (Control.Arrow.Trans.Cod (Control.Arrow.Transformer.Abstract.Store.StoreT var val) x y) c => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Abstract.Store.StoreT var val c)
instance (Data.Identifiable.Identifiable var, Control.Arrow.ArrowChoice c, Control.Arrow.Abstract.Join.ArrowJoin c, Data.Profunctor.Unsafe.Profunctor c, Data.Order.Complete val) => Control.Arrow.Store.ArrowStore var val (Control.Arrow.Transformer.Abstract.Store.StoreT var val c)
instance Control.Arrow.State.ArrowState s c => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Abstract.Store.StoreT var val c)
instance (Control.Arrow.ArrowApply c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Abstract.Store.StoreT var val c)

module Control.Arrow.Transformer.Abstract.ReachingDefinitions
newtype ReachingDefsT lab c x y
ReachingDefsT :: ReaderT (Maybe lab) c x y -> ReachingDefsT lab c x y
reachingDefsT :: (Arrow c, Profunctor c) => c (Maybe lab, x) y -> ReachingDefsT lab c x y
runReachingDefsT :: (Arrow c, Profunctor c) => ReachingDefsT lab c x y -> c (Maybe lab, x) y
runReachingDefsT' :: (Arrow c, Profunctor c) => ReachingDefsT lab c x y -> c x y
instance Control.Arrow.Abstract.Join.ArrowJoin c => Control.Arrow.Abstract.Join.ArrowJoin (Control.Arrow.Transformer.Abstract.ReachingDefinitions.ReachingDefsT lab c)
instance Control.Arrow.Environment.ArrowEnv var val env c => Control.Arrow.Environment.ArrowEnv var val env (Control.Arrow.Transformer.Abstract.ReachingDefinitions.ReachingDefsT lab c)
instance Control.Arrow.State.ArrowState s c => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Abstract.ReachingDefinitions.ReachingDefsT lab c)
instance Control.Arrow.Except.ArrowExcept e c => Control.Arrow.Except.ArrowExcept e (Control.Arrow.Transformer.Abstract.ReachingDefinitions.ReachingDefsT lab c)
instance Control.Arrow.Fail.ArrowFail e c => Control.Arrow.Fail.ArrowFail e (Control.Arrow.Transformer.Abstract.ReachingDefinitions.ReachingDefsT lab c)
instance Control.Arrow.Trans.ArrowLift (Control.Arrow.Transformer.Abstract.ReachingDefinitions.ReachingDefsT lab)
instance Control.Arrow.Trans.ArrowTrans (Control.Arrow.Transformer.Abstract.ReachingDefinitions.ReachingDefsT lab)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Abstract.ReachingDefinitions.ReachingDefsT lab c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Abstract.ReachingDefinitions.ReachingDefsT lab c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Abstract.ReachingDefinitions.ReachingDefsT lab c)
instance (Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.Arrow c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Abstract.ReachingDefinitions.ReachingDefsT lab c)
instance (Data.Identifiable.Identifiable var, Data.Identifiable.Identifiable lab, Control.Arrow.Store.ArrowStore var (val, Data.Abstract.DiscretePowerset.Pow lab) c) => Control.Arrow.Store.ArrowStore var val (Control.Arrow.Transformer.Abstract.ReachingDefinitions.ReachingDefsT lab c)
instance (Data.Label.HasLabel x lab, Control.Arrow.Arrow c, Control.Arrow.Fix.ArrowFix x y c) => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Abstract.ReachingDefinitions.ReachingDefsT lab c)
instance (Control.Arrow.ArrowApply c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Abstract.ReachingDefinitions.ReachingDefsT lab c)
instance Control.Arrow.Reader.ArrowReader r c => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.Abstract.ReachingDefinitions.ReachingDefsT lab c)
instance Control.Arrow.Alloc.ArrowAlloc x y c => Control.Arrow.Alloc.ArrowAlloc x y (Control.Arrow.Transformer.Abstract.ReachingDefinitions.ReachingDefsT lab c)

module Control.Arrow.Transformer.Abstract.Powerset

-- | Computation that produces a set of results.
data PowT c x y
runPowT :: PowT c x y -> c x (Pow y)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Except.ArrowExcept e' c) => Control.Arrow.Except.ArrowExcept e' (Control.Arrow.Transformer.Abstract.Powerset.PowT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Fail.ArrowFail e' c) => Control.Arrow.Fail.ArrowFail e' (Control.Arrow.Transformer.Abstract.Powerset.PowT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Store.ArrowStore a b c) => Control.Arrow.Store.ArrowStore a b (Control.Arrow.Transformer.Abstract.Powerset.PowT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Environment.ArrowEnv a b e' c) => Control.Arrow.Environment.ArrowEnv a b e' (Control.Arrow.Transformer.Abstract.Powerset.PowT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Const.ArrowConst r c) => Control.Arrow.Const.ArrowConst r (Control.Arrow.Transformer.Abstract.Powerset.PowT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Reader.ArrowReader r c) => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.Abstract.Powerset.PowT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.State.ArrowState s c) => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Abstract.Powerset.PowT c)
instance Control.Arrow.Trans.ArrowLift Control.Arrow.Transformer.Abstract.Powerset.PowT
instance Control.Arrow.Trans.ArrowTrans Control.Arrow.Transformer.Abstract.Powerset.PowT
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Abstract.Powerset.PowT c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Abstract.Powerset.PowT c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Abstract.Powerset.PowT c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Abstract.Powerset.PowT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Fix.ArrowFix x (Data.Abstract.Powerset.Pow y) c) => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Abstract.Powerset.PowT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Deduplicate.ArrowDeduplicate x y c, Data.Identifiable.Identifiable y) => Control.Arrow.Deduplicate.ArrowDeduplicate x y (Control.Arrow.Transformer.Abstract.Powerset.PowT c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.ArrowApply c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Abstract.Powerset.PowT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Abstract.Join.ArrowJoin c) => Control.Arrow.Abstract.Join.ArrowJoin (Control.Arrow.Transformer.Abstract.Powerset.PowT c)

module Control.Arrow.Transformer.Abstract.Failure

-- | Describes computations that can fail.
data FailureT e c x y
runFailureT :: FailureT e c x y -> c x (Failure e y)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Except.ArrowExcept e' c) => Control.Arrow.Except.ArrowExcept e' (Control.Arrow.Transformer.Abstract.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Store.ArrowStore a b c) => Control.Arrow.Store.ArrowStore a b (Control.Arrow.Transformer.Abstract.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Environment.ArrowEnv a b e' c) => Control.Arrow.Environment.ArrowEnv a b e' (Control.Arrow.Transformer.Abstract.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Const.ArrowConst r c) => Control.Arrow.Const.ArrowConst r (Control.Arrow.Transformer.Abstract.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Reader.ArrowReader r c) => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.Abstract.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.State.ArrowState s c) => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Abstract.Failure.FailureT e c)
instance Control.Arrow.Trans.ArrowLift (Control.Arrow.Transformer.Abstract.Failure.FailureT e)
instance Control.Arrow.Trans.ArrowTrans (Control.Arrow.Transformer.Abstract.Failure.FailureT e)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Abstract.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Abstract.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Abstract.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Abstract.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Fix.ArrowFix (Control.Arrow.Trans.Dom (Control.Arrow.Transformer.Abstract.Failure.FailureT e) x y) (Control.Arrow.Trans.Cod (Control.Arrow.Transformer.Abstract.Failure.FailureT e) x y) c) => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Abstract.Failure.FailureT e c)
instance (Data.Identifiable.Identifiable (Control.Arrow.Trans.Cod (Control.Arrow.Transformer.Abstract.Failure.FailureT e) x y), Control.Arrow.ArrowChoice c, Control.Arrow.Deduplicate.ArrowDeduplicate (Control.Arrow.Trans.Dom (Control.Arrow.Transformer.Abstract.Failure.FailureT e) x y) (Control.Arrow.Trans.Cod (Control.Arrow.Transformer.Abstract.Failure.FailureT e) x y) c) => Control.Arrow.Deduplicate.ArrowDeduplicate x y (Control.Arrow.Transformer.Abstract.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Fail.ArrowFail e (Control.Arrow.Transformer.Abstract.Failure.FailureT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.ArrowApply c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Abstract.Failure.FailureT e c)
instance (Control.Arrow.Abstract.Join.ArrowJoin c, Control.Arrow.ArrowChoice c) => Control.Arrow.Abstract.Join.ArrowJoin (Control.Arrow.Transformer.Abstract.Failure.FailureT e c)

module Control.Arrow.Transformer.Abstract.Except
data ExceptT e c x y
runExceptT :: ExceptT e c x y -> c x (Except e y)
instance (Data.Order.Complete e, Control.Arrow.Abstract.Join.ArrowJoin c, Control.Arrow.ArrowChoice c, Control.Arrow.Fail.ArrowFail e' c) => Control.Arrow.Fail.ArrowFail e' (Control.Arrow.Transformer.Abstract.Except.ExceptT e c)
instance (Data.Order.Complete e, Control.Arrow.Abstract.Join.ArrowJoin c, Control.Arrow.ArrowChoice c, Control.Arrow.Store.ArrowStore a b c) => Control.Arrow.Store.ArrowStore a b (Control.Arrow.Transformer.Abstract.Except.ExceptT e c)
instance (Data.Order.Complete e, Control.Arrow.Abstract.Join.ArrowJoin c, Control.Arrow.ArrowChoice c, Control.Arrow.Environment.ArrowEnv a b e' c) => Control.Arrow.Environment.ArrowEnv a b e' (Control.Arrow.Transformer.Abstract.Except.ExceptT e c)
instance (Data.Order.Complete e, Control.Arrow.Abstract.Join.ArrowJoin c, Control.Arrow.ArrowChoice c, Control.Arrow.Const.ArrowConst r c) => Control.Arrow.Const.ArrowConst r (Control.Arrow.Transformer.Abstract.Except.ExceptT e c)
instance (Data.Order.Complete e, Control.Arrow.Abstract.Join.ArrowJoin c, Control.Arrow.ArrowChoice c, Control.Arrow.Reader.ArrowReader r c) => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.Abstract.Except.ExceptT e c)
instance (Data.Order.Complete e, Control.Arrow.Abstract.Join.ArrowJoin c, Control.Arrow.ArrowChoice c, Control.Arrow.State.ArrowState s c) => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Abstract.Except.ExceptT e c)
instance Data.Order.Complete e => Control.Arrow.Trans.ArrowLift (Control.Arrow.Transformer.Abstract.Except.ExceptT e)
instance Control.Arrow.Trans.ArrowTrans (Control.Arrow.Transformer.Abstract.Except.ExceptT e)
instance (Data.Order.Complete e, Control.Arrow.Abstract.Join.ArrowJoin c, Control.Arrow.ArrowChoice c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Abstract.Except.ExceptT e c)
instance (Data.Order.Complete e, Control.Arrow.Abstract.Join.ArrowJoin c, Control.Arrow.ArrowChoice c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Abstract.Except.ExceptT e c)
instance (Data.Order.Complete e, Control.Arrow.Abstract.Join.ArrowJoin c, Control.Arrow.ArrowChoice c) => Control.Category.Category (Control.Arrow.Transformer.Abstract.Except.ExceptT e c)
instance (Data.Order.Complete e, Control.Arrow.Abstract.Join.ArrowJoin c, Control.Arrow.ArrowChoice c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Abstract.Except.ExceptT e c)
instance (Data.Order.Complete e, Control.Arrow.Abstract.Join.ArrowJoin c, Control.Arrow.ArrowChoice c, Control.Arrow.Fix.ArrowFix (Control.Arrow.Trans.Dom (Control.Arrow.Transformer.Abstract.Except.ExceptT e) x y) (Control.Arrow.Trans.Cod (Control.Arrow.Transformer.Abstract.Except.ExceptT e) x y) c) => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Abstract.Except.ExceptT e c)
instance (Data.Order.Complete e, Control.Arrow.Abstract.Join.ArrowJoin c, Data.Identifiable.Identifiable (Control.Arrow.Trans.Cod (Control.Arrow.Transformer.Abstract.Except.ExceptT e) x y), Control.Arrow.ArrowChoice c, Control.Arrow.Deduplicate.ArrowDeduplicate (Control.Arrow.Trans.Dom (Control.Arrow.Transformer.Abstract.Except.ExceptT e) x y) (Control.Arrow.Trans.Cod (Control.Arrow.Transformer.Abstract.Except.ExceptT e) x y) c) => Control.Arrow.Deduplicate.ArrowDeduplicate x y (Control.Arrow.Transformer.Abstract.Except.ExceptT e c)
instance (Control.Arrow.ArrowChoice c, Data.Order.Complete e, Control.Arrow.Abstract.Join.ArrowJoin c) => Control.Arrow.Except.ArrowExcept e (Control.Arrow.Transformer.Abstract.Except.ExceptT e c)
instance (Data.Order.Complete e, Control.Arrow.Abstract.Join.ArrowJoin c, Control.Arrow.ArrowChoice c, Control.Arrow.ArrowApply c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Abstract.Except.ExceptT e c)
instance (Data.Order.Complete e, Control.Arrow.Abstract.Join.ArrowJoin c, Control.Arrow.ArrowChoice c) => Control.Arrow.Abstract.Join.ArrowJoin (Control.Arrow.Transformer.Abstract.Except.ExceptT e c)

module Control.Arrow.Transformer.Abstract.Error
data ErrorT e c x y
runErrorT :: ErrorT e c x y -> c x (Error e y)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Except.ArrowExcept e' c) => Control.Arrow.Except.ArrowExcept e' (Control.Arrow.Transformer.Abstract.Error.ErrorT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Store.ArrowStore a b c) => Control.Arrow.Store.ArrowStore a b (Control.Arrow.Transformer.Abstract.Error.ErrorT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Environment.ArrowEnv a b e' c) => Control.Arrow.Environment.ArrowEnv a b e' (Control.Arrow.Transformer.Abstract.Error.ErrorT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Const.ArrowConst r c) => Control.Arrow.Const.ArrowConst r (Control.Arrow.Transformer.Abstract.Error.ErrorT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Reader.ArrowReader r c) => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.Abstract.Error.ErrorT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.State.ArrowState s c) => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Abstract.Error.ErrorT e c)
instance Control.Arrow.Trans.ArrowLift (Control.Arrow.Transformer.Abstract.Error.ErrorT e)
instance Control.Arrow.Trans.ArrowTrans (Control.Arrow.Transformer.Abstract.Error.ErrorT e)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Abstract.Error.ErrorT e c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Abstract.Error.ErrorT e c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Abstract.Error.ErrorT e c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Abstract.Error.ErrorT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Fix.ArrowFix (Control.Arrow.Trans.Dom (Control.Arrow.Transformer.Abstract.Error.ErrorT e) x y) (Control.Arrow.Trans.Cod (Control.Arrow.Transformer.Abstract.Error.ErrorT e) x y) c) => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Abstract.Error.ErrorT e c)
instance (Data.Identifiable.Identifiable (Control.Arrow.Trans.Cod (Control.Arrow.Transformer.Abstract.Error.ErrorT e) x y), Control.Arrow.ArrowChoice c, Control.Arrow.Deduplicate.ArrowDeduplicate (Control.Arrow.Trans.Dom (Control.Arrow.Transformer.Abstract.Error.ErrorT e) x y) (Control.Arrow.Trans.Cod (Control.Arrow.Transformer.Abstract.Error.ErrorT e) x y) c) => Control.Arrow.Deduplicate.ArrowDeduplicate x y (Control.Arrow.Transformer.Abstract.Error.ErrorT e c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Fail.ArrowFail e (Control.Arrow.Transformer.Abstract.Error.ErrorT e c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.ArrowApply c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Abstract.Error.ErrorT e c)
instance (Data.Order.Complete e, Control.Arrow.Abstract.Join.ArrowJoin c, Control.Arrow.ArrowChoice c) => Control.Arrow.Abstract.Join.ArrowJoin (Control.Arrow.Transformer.Abstract.Error.ErrorT e c)

module Control.Arrow.Transformer.Abstract.Environment
newtype EnvT var val c x y
EnvT :: ReaderT (Map var val) c x y -> EnvT var val c x y
runEnvT :: (Arrow c, Profunctor c) => EnvT var val c x y -> c (Map var val, x) y
runEnvT' :: (Arrow c, Profunctor c, Identifiable var) => EnvT var val c x y -> c ([(var, val)], x) y
instance Control.Arrow.Const.ArrowConst k c => Control.Arrow.Const.ArrowConst k (Control.Arrow.Transformer.Abstract.Environment.EnvT var val c)
instance Control.Arrow.Store.ArrowStore var' val' c => Control.Arrow.Store.ArrowStore var' val' (Control.Arrow.Transformer.Abstract.Environment.EnvT var val c)
instance Control.Arrow.Except.ArrowExcept e c => Control.Arrow.Except.ArrowExcept e (Control.Arrow.Transformer.Abstract.Environment.EnvT var val c)
instance Control.Arrow.Fail.ArrowFail e c => Control.Arrow.Fail.ArrowFail e (Control.Arrow.Transformer.Abstract.Environment.EnvT var val c)
instance Control.Arrow.State.ArrowState s c => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Abstract.Environment.EnvT var val c)
instance Control.Arrow.Abstract.Join.ArrowJoin c => Control.Arrow.Abstract.Join.ArrowJoin (Control.Arrow.Transformer.Abstract.Environment.EnvT var val c)
instance Control.Arrow.Trans.ArrowLift (Control.Arrow.Transformer.Abstract.Environment.EnvT var val)
instance Control.Arrow.Trans.ArrowTrans (Control.Arrow.Transformer.Abstract.Environment.EnvT var val)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Abstract.Environment.EnvT var val c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Abstract.Environment.EnvT var val c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Abstract.Environment.EnvT var val c)
instance (Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.Arrow c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Abstract.Environment.EnvT var val c)
instance Control.Arrow.Fix.ArrowFix (Data.Abstract.StrongMap.Map var val, x) y c => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Abstract.Environment.EnvT var val c)
instance (Data.Identifiable.Identifiable var, Data.Order.UpperBounded val, Control.Arrow.ArrowChoice c, Control.Arrow.Abstract.Join.ArrowJoin c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Environment.ArrowEnv var val (Data.Abstract.StrongMap.Map var val) (Control.Arrow.Transformer.Abstract.Environment.EnvT var val c)
instance (Control.Arrow.ArrowApply c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Abstract.Environment.EnvT var val c)
instance Control.Arrow.Reader.ArrowReader r c => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.Abstract.Environment.EnvT var val c)

module Control.Arrow.Transformer.Abstract.Contour
data CallString lab

-- | Records the k-bounded call string. Meant to be used in conjunction
--   with <a>BoundedEnvironment</a>.
data ContourT lab c a b

-- | Runs a computation that records a call string. The argument <tt>k</tt>
--   specifies the maximum length of a call string. All larger call strings
--   are truncated to at most <tt>k</tt> elements.
runContourT :: (Arrow c, Profunctor c) => Int -> ContourT lab c a b -> c a b
instance Control.Arrow.Abstract.Join.ArrowJoin c => Control.Arrow.Abstract.Join.ArrowJoin (Control.Arrow.Transformer.Abstract.Contour.ContourT lab c)
instance Control.Arrow.Except.ArrowExcept e c => Control.Arrow.Except.ArrowExcept e (Control.Arrow.Transformer.Abstract.Contour.ContourT lab c)
instance Control.Arrow.Fail.ArrowFail e c => Control.Arrow.Fail.ArrowFail e (Control.Arrow.Transformer.Abstract.Contour.ContourT lab c)
instance Control.Arrow.Environment.ArrowEnv x y env c => Control.Arrow.Environment.ArrowEnv x y env (Control.Arrow.Transformer.Abstract.Contour.ContourT lab c)
instance Control.Arrow.State.ArrowState s c => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Abstract.Contour.ContourT lab c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Abstract.Contour.ContourT lab c)
instance Control.Arrow.Trans.ArrowLift (Control.Arrow.Transformer.Abstract.Contour.ContourT lab)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Abstract.Contour.ContourT lab c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Abstract.Contour.ContourT lab c)
instance (Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.Arrow c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Abstract.Contour.ContourT lab c)
instance (Control.Arrow.Fix.ArrowFix x y c, Control.Arrow.ArrowApply c, Data.Label.HasLabel x lab, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Abstract.Contour.ContourT lab c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Alloc.ArrowAlloc (var, val, env) (var, Data.CallString.CallString lab) (Control.Arrow.Transformer.Abstract.Contour.ContourT lab c)
instance (Control.Arrow.ArrowApply c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Abstract.Contour.ContourT lab c)
instance Control.Arrow.Reader.ArrowReader r c => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.Abstract.Contour.ContourT lab c)

module Control.Arrow.Transformer.Abstract.Completion

-- | Allows to describe computations over non-completely ordered types.
--   E.g. allows to join a computation of type 'c x [y]'.
data CompletionT c x y
runCompletionT :: CompletionT c x y -> c x (FreeCompletion y)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Except.ArrowExcept e c) => Control.Arrow.Except.ArrowExcept e (Control.Arrow.Transformer.Abstract.Completion.CompletionT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Fail.ArrowFail e c) => Control.Arrow.Fail.ArrowFail e (Control.Arrow.Transformer.Abstract.Completion.CompletionT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Store.ArrowStore a b c) => Control.Arrow.Store.ArrowStore a b (Control.Arrow.Transformer.Abstract.Completion.CompletionT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Environment.ArrowEnv a b e c) => Control.Arrow.Environment.ArrowEnv a b e (Control.Arrow.Transformer.Abstract.Completion.CompletionT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Const.ArrowConst r c) => Control.Arrow.Const.ArrowConst r (Control.Arrow.Transformer.Abstract.Completion.CompletionT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Reader.ArrowReader r c) => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.Abstract.Completion.CompletionT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.State.ArrowState s c) => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Abstract.Completion.CompletionT c)
instance Control.Arrow.Trans.ArrowLift Control.Arrow.Transformer.Abstract.Completion.CompletionT
instance Control.Arrow.Trans.ArrowTrans Control.Arrow.Transformer.Abstract.Completion.CompletionT
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Abstract.Completion.CompletionT c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Abstract.Completion.CompletionT c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Abstract.Completion.CompletionT c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Abstract.Completion.CompletionT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Fix.ArrowFix (Control.Arrow.Trans.Dom Control.Arrow.Transformer.Abstract.Completion.CompletionT x y) (Control.Arrow.Trans.Cod Control.Arrow.Transformer.Abstract.Completion.CompletionT x y) c) => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Abstract.Completion.CompletionT c)
instance (Data.Identifiable.Identifiable (Control.Arrow.Trans.Cod Control.Arrow.Transformer.Abstract.Completion.CompletionT x y), Control.Arrow.ArrowChoice c, Control.Arrow.Deduplicate.ArrowDeduplicate (Control.Arrow.Trans.Dom Control.Arrow.Transformer.Abstract.Completion.CompletionT x y) (Control.Arrow.Trans.Cod Control.Arrow.Transformer.Abstract.Completion.CompletionT x y) c) => Control.Arrow.Deduplicate.ArrowDeduplicate x y (Control.Arrow.Transformer.Abstract.Completion.CompletionT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.ArrowApply c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Abstract.Completion.CompletionT c)
instance (Control.Arrow.ArrowChoice c, Control.Arrow.Abstract.Join.ArrowJoin c) => Control.Arrow.Abstract.Join.ArrowJoin (Control.Arrow.Transformer.Abstract.Completion.CompletionT c)

module Control.Arrow.Transformer.Abstract.BoundedEnvironment

-- | Abstract domain for environments in which concrete environments are
--   approximated by a mapping from variables to addresses and a mapping
--   from addresses to values. The number of allocated addresses allows to
--   tune the precision and performance of the analysis.
--
--   Abstract domain for environments in which concrete environments are
--   approximated by a mapping from variables to addresses and a mapping
--   from addresses to values. The number of allocated addresses allows to
--   tune the precision and performance of the analysis.
--
--   Furthermore, closures and environments are defined mutually
--   recursively. By only allowing a finite number of addresses, the
--   abstract domain of closures and environments becomes finite.
data EnvT var addr val c x y
runEnvT :: (Show var, Identifiable var, Identifiable addr, Complete val, ArrowJoin c, ArrowChoice c, Profunctor c) => c (var, val, Map var addr val) addr -> EnvT var addr val c x y -> c ([(var, val)], x) y
instance Control.Arrow.Abstract.Join.ArrowJoin c => Control.Arrow.Abstract.Join.ArrowJoin (Control.Arrow.Transformer.Abstract.BoundedEnvironment.EnvT var addr val c)
instance Control.Arrow.Except.ArrowExcept e c => Control.Arrow.Except.ArrowExcept e (Control.Arrow.Transformer.Abstract.BoundedEnvironment.EnvT var addr val c)
instance Control.Arrow.Fail.ArrowFail e c => Control.Arrow.Fail.ArrowFail e (Control.Arrow.Transformer.Abstract.BoundedEnvironment.EnvT var addr val c)
instance Control.Arrow.State.ArrowState s c => Control.Arrow.State.ArrowState s (Control.Arrow.Transformer.Abstract.BoundedEnvironment.EnvT var addr val c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Abstract.BoundedEnvironment.EnvT var addr val c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Abstract.BoundedEnvironment.EnvT var addr val c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Abstract.BoundedEnvironment.EnvT var addr val c)
instance (Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.Arrow c) => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Abstract.BoundedEnvironment.EnvT var addr val c)
instance Control.Arrow.Fix.ArrowFix (Control.Arrow.Trans.Dom (Control.Arrow.Transformer.Abstract.BoundedEnvironment.EnvT var addr val) x y) (Control.Arrow.Trans.Cod (Control.Arrow.Transformer.Abstract.BoundedEnvironment.EnvT var addr val) x y) c => Control.Arrow.Fix.ArrowFix x y (Control.Arrow.Transformer.Abstract.BoundedEnvironment.EnvT var addr val c)
instance Control.Arrow.Trans.ArrowTrans (Control.Arrow.Transformer.Abstract.BoundedEnvironment.EnvT var addr val)
instance Control.Arrow.Trans.ArrowLift (Control.Arrow.Transformer.Abstract.BoundedEnvironment.EnvT var addr val)
instance (Data.Identifiable.Identifiable var, Data.Identifiable.Identifiable addr, Data.Order.Complete val, Control.Arrow.ArrowChoice c, Control.Arrow.Abstract.Join.ArrowJoin c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Environment.ArrowEnv var val (Data.Abstract.FiniteMap.Map var addr val) (Control.Arrow.Transformer.Abstract.BoundedEnvironment.EnvT var addr val c)
instance Control.Arrow.Reader.ArrowReader r c => Control.Arrow.Reader.ArrowReader r (Control.Arrow.Transformer.Abstract.BoundedEnvironment.EnvT var addr val c)
instance (Control.Arrow.ArrowApply c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Abstract.BoundedEnvironment.EnvT var addr val c)

module Data.Utils
lookupM :: (Ord k, Monoid v) => k -> Map k v -> v
maybeHead :: [a] -> Maybe a

module Data.Abstract.StackWidening

-- | A stack widening operator <tt>(▽ :: s -&gt; a -&gt; (s,a))</tt>
--   follows the same idea as a regular widening operator, but does not
--   have the restriction that the input chain has to be ascending: Given
--   an infinite series <tt>x1, x2, x3, x4 ...</tt>, the stack widening
--   operator produces a series <tt> x1 ▽ s1 = (x1',s2) &amp; x1 ⊑ x1' x2 ▽
--   s2 = (x2',s3) &amp; x2 ⊑ x2' x3 ▽ s3 = (x3',s4) &amp; x3 ⊑ x3' x4 ▽ s4
--   = (x4',s5) &amp; x4 ⊑ x4' ... </tt> such that <tt>x1', x2', x3'
--   ...</tt> repeats itself, i.e. there exists <tt>n,m</tt> with <tt>n /=
--   m</tt> and <tt>xn' = xm'</tt>.
type StackWidening stack a = a -> stack a -> (a, stack a)
finite :: StackWidening Unit a
groupBy :: (IsEmpty (stack a'), Identifiable k) => Iso' a (k, a') -> StackWidening stack a' -> StackWidening (Groups stack k a') a
maxSize :: Int -> StackWidening s a -> StackWidening (Size ** s) a
fromWidening :: Complete a => Widening a -> StackWidening s a -> StackWidening (Last ** s) a
reuse :: Identifiable a => (a -> HashSet a -> Maybe a) -> StackWidening s a -> StackWidening (Stack ** s) a
reuseFirst :: (Identifiable a, PreOrd a) => StackWidening s a -> StackWidening (Stack ** s) a
data Groups s k a' a
Groups :: HashMap k (s a') -> Groups s k a' a
data Size a
Size :: Int -> Size a
data Stack a
Stack :: HashSet a -> Stack a
newtype Last a
Last :: Maybe a -> Last a
data ( s1 ** s2 ) a
Product :: s1 a -> s2 a -> (**) s1 s2 a
newtype Const s a' a
Const :: s a' -> Const s a' a
[getConst] :: Const s a' a -> s a'
data Unit a
Unit :: Unit a
instance forall k (a :: k). GHC.Show.Show (Data.Abstract.StackWidening.Unit a)
instance forall k (a :: k). GHC.Show.Show (Data.Abstract.StackWidening.Size a)
instance forall k (a :: k). Data.Empty.IsEmpty (Data.Abstract.StackWidening.Unit a)
instance forall k1 k2 (s :: k2 -> *) (a' :: k2) (a :: k1). GHC.Show.Show (s a') => GHC.Show.Show (Data.Abstract.StackWidening.Const s a' a)
instance forall k1 k2 (s :: k2 -> *) (a' :: k2) (a :: k1). Data.Empty.IsEmpty (s a') => Data.Empty.IsEmpty (Data.Abstract.StackWidening.Const s a' a)
instance forall k (s1 :: k -> *) (a :: k) (s2 :: k -> *). (GHC.Show.Show (s1 a), GHC.Show.Show (s2 a)) => GHC.Show.Show ((Data.Abstract.StackWidening.**) s1 s2 a)
instance forall k (s1 :: k -> *) (a :: k) (s2 :: k -> *). (Data.Empty.IsEmpty (s1 a), Data.Empty.IsEmpty (s2 a)) => Data.Empty.IsEmpty ((Data.Abstract.StackWidening.**) s1 s2 a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Abstract.StackWidening.Last a)
instance Data.Empty.IsEmpty (Data.Abstract.StackWidening.Last a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Abstract.StackWidening.Stack a)
instance Data.Empty.IsEmpty (Data.Abstract.StackWidening.Stack a)
instance forall k (a :: k). Data.Empty.IsEmpty (Data.Abstract.StackWidening.Size a)
instance forall k1 k2 k3 (s :: k2 -> *) (a' :: k2) (a :: k1). (GHC.Show.Show k3, GHC.Show.Show (s a')) => GHC.Show.Show (Data.Abstract.StackWidening.Groups s k3 a' a)
instance forall k1 k2 k3 (c :: k2 -> *) (a' :: k2) (a :: k1). Data.Identifiable.Identifiable k3 => Data.Empty.IsEmpty (Data.Abstract.StackWidening.Groups c k3 a' a)

module Data.Abstract.IterationStrategy

-- | The iteration strategy <tt>▽</tt> ensures that a recursive computation
--   terminates, soundly approximates the fixed point and avoids redundant
--   computation.
--
--   It ensures termination by transforming an infinite series <tt>x1, x2,
--   x3 ...</tt>, to a finite series: <tt> x1 ▽ s1 = (Compute x1',s2) &amp;
--   x1 ⊑ x1' x2 ▽ s2 = (Compute x2',s3) &amp; x2 ⊑ x2' x3 ▽ s3 = (Compute
--   x3',s4) &amp; x3 ⊑ x3' ... xn ▽ sn = (Cached y,sn+1) </tt> Of course
--   this is only sound if we iterate on inputs that recursively depend on
--   themselves. For example, <tt> x1 ▽ s1 = (ComputeAndIterate x1',s2) x2
--   ▽ s2 = (Compute x2',s3) x3 ▽ s3 = (Cached (lookupDefault x1' bottom
--   s3),s4) </tt> Because <tt>x3 ⊑ x1'</tt>, we can reuse the result of
--   <tt>x1'</tt> at the loss of precision. However, since the result of
--   <tt>x1'</tt> has not been computed yet, we initialize the result with
--   <tt>bottom</tt> and iterate on it until it stabilized.
--
--   The iteration strategy can also avoid redundant computation by
--   returning cached results instead of recomputing them.
type IterationStrategy c a b = c a b -> c a b
class ArrowRun t
run :: (ArrowRun t, Profunctor c) => t c a b -> c a b
filter :: (Profunctor c, ArrowChoice c, ArrowApply c) => Prism' a a' -> IterationStrategy c a' b -> IterationStrategy c a b
data Cache a b
Cache :: HashMap a b -> HashMap a b -> Cache a b
[old] :: Cache a b -> HashMap a b
[new] :: Cache a b -> HashMap a b
newtype ParallelT s a b c x y
ParallelT :: StateT (Cache a b) (ReaderT (Stack a, s a) c) x y -> ParallelT s a b c x y
parallel :: (Identifiable a, LowerBounded b, Profunctor c, ArrowChoice c) => StackWidening s a -> Widening b -> IterationStrategy (ParallelT s a b c) a b
data Component a
Component :: HashSet a -> HashSet a -> Component a
[head] :: Component a -> HashSet a
[body] :: Component a -> HashSet a
newtype ChaoticT s a b c x y
ChaoticT :: WriterT (Component a) (StateT (HashMap a (b, Stable)) (ReaderT (Stack a, s a) c)) x y -> ChaoticT s a b c x y
runChaoticT :: (IsEmpty (s a), Profunctor c) => ChaoticT s a b c x y -> c x (HashMap a (b, Stable), y)
chaotic :: (Identifiable a, LowerBounded b, Profunctor c, ArrowChoice c, ArrowApply c) => StackWidening s a -> Widening b -> IterationStrategy (ChaoticT s a b c) a b
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a, Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Data.Abstract.IterationStrategy.ChaoticT s a b c)
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a, Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Data.Abstract.IterationStrategy.ChaoticT s a b c)
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a, Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Data.Abstract.IterationStrategy.ChaoticT s a b c)
instance (Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.Arrow c) => Data.Profunctor.Unsafe.Profunctor (Data.Abstract.IterationStrategy.ChaoticT s a b c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Data.Abstract.IterationStrategy.ParallelT s a b c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Data.Abstract.IterationStrategy.ParallelT s a b c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Data.Abstract.IterationStrategy.ParallelT s a b c)
instance (Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.Arrow c) => Data.Profunctor.Unsafe.Profunctor (Data.Abstract.IterationStrategy.ParallelT s a b c)
instance (Data.Identifiable.Identifiable a, Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.ArrowApply c) => Control.Arrow.ArrowApply (Data.Abstract.IterationStrategy.ChaoticT s a b c)
instance Data.Empty.IsEmpty (s a) => Data.Abstract.IterationStrategy.ArrowRun (Data.Abstract.IterationStrategy.ChaoticT s a b)
instance (Data.Identifiable.Identifiable a, Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.Arrow c) => Control.Arrow.Abstract.Join.ArrowJoin (Data.Abstract.IterationStrategy.ChaoticT s a b c)
instance Data.Identifiable.Identifiable a => GHC.Base.Semigroup (Data.Abstract.IterationStrategy.Component a)
instance Data.Identifiable.Identifiable a => GHC.Base.Monoid (Data.Abstract.IterationStrategy.Component a)
instance (Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.ArrowApply c) => Control.Arrow.ArrowApply (Data.Abstract.IterationStrategy.ParallelT s a b c)
instance (Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.Arrow c) => Control.Arrow.Abstract.Join.ArrowJoin (Data.Abstract.IterationStrategy.ParallelT s a b c)
instance Data.Empty.IsEmpty (s a) => Data.Abstract.IterationStrategy.ArrowRun (Data.Abstract.IterationStrategy.ParallelT s a b)
instance Data.Empty.IsEmpty (Data.Abstract.IterationStrategy.Cache a b)

module Control.Arrow.Transformer.Abstract.Fix
data FixT a b c x y
runFixT :: (Identifiable a, PreOrd b, Profunctor c, ArrowRun t) => IterationStrategy (t c) a b -> FixT a b (t c) x y -> c x y
runFixT' :: (Identifiable a, PreOrd b) => IterationStrategy c a b -> FixT a b c x y -> c x y
instance Control.Arrow.Abstract.Join.ArrowJoin c => Control.Arrow.Abstract.Join.ArrowJoin (Control.Arrow.Transformer.Abstract.Fix.FixT a b c)
instance (Control.Arrow.ArrowChoice c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.ArrowChoice (Control.Arrow.Transformer.Abstract.Fix.FixT a b c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Arrow.Arrow (Control.Arrow.Transformer.Abstract.Fix.FixT a b c)
instance (Control.Arrow.Arrow c, Data.Profunctor.Unsafe.Profunctor c) => Control.Category.Category (Control.Arrow.Transformer.Abstract.Fix.FixT a b c)
instance Data.Profunctor.Unsafe.Profunctor c => Data.Profunctor.Unsafe.Profunctor (Control.Arrow.Transformer.Abstract.Fix.FixT a b c)
instance (Data.Identifiable.Identifiable a, Data.Order.LowerBounded b, Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.ArrowChoice c, Control.Arrow.ArrowApply c) => Control.Arrow.Fix.ArrowFix a b (Control.Arrow.Transformer.Abstract.Fix.FixT a b c)
instance (Data.Profunctor.Unsafe.Profunctor c, Control.Arrow.ArrowApply c) => Control.Arrow.ArrowApply (Control.Arrow.Transformer.Abstract.Fix.FixT a b c)
instance Control.Arrow.Trans.ArrowLift (Control.Arrow.Transformer.Abstract.Fix.FixT a b)
